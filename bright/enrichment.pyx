################################################
#                 WARNING!                     #
# This file has been auto-generated by Bright. #
# Do not modify!!!                             #
#                                              #
#                                              #
#                    Come on, guys. I mean it! #
################################################
"""Python wrapper for enrichment.
"""
cimport enrichment_parameters
cimport fccomp
cimport pyne.stlcontainers
from bright cimport cpp_enrichment_parameters
from bright cimport cpp_fccomp
from libcpp.map cimport map as cpp_map
from libcpp.string cimport string as std_string
from pyne cimport cpp_material
from pyne cimport cpp_nucname
from pyne cimport material
from pyne cimport nucname

from pyne import material
from pyne import nucname
import enrichment_parameters
import fccomp
import pyne.stlcontainers

cdef class Enrichment(fccomp.FCComp):
    """Enrichment Fuel Cycle Component Class.  Daughter of FCComp.
    
    Parameters
    ----------
    ep : EnrichmentParameters, optional 
        This specifies how the enrichment cascade should be set up.  It is a 
        EnrichmentParameters instance.  If enrich_params is not specified, then 
        the cascade is initialized with values from uranium_enrichment_defaults().
    n : str, optional
        The name of the enrichment fuel cycle component instance.
    
    """

    # constuctors
    def __cinit__(self, *args, **kwargs):
        self._inst = NULL
        self._free_inst = True

        # cached property defaults
        self._mat_tail = None

    def _enrichment_enrichment_0(self, ep, n=""):
        """Enrichment(self, ep, n="")
        """
        cdef enrichment_parameters.EnrichmentParameters ep_proxy
        ep_proxy = <enrichment_parameters.EnrichmentParameters> ep
        self._inst = new cpp_enrichment.Enrichment((<cpp_enrichment_parameters.EnrichmentParameters *> ep_proxy._inst)[0], std_string(<char *> n))
    
    
    def _enrichment_enrichment_1(self, n=""):
        """Enrichment(self, n="")
        """
        self._inst = new cpp_enrichment.Enrichment(std_string(<char *> n))
    
    
    _enrichment_enrichment_0_argtypes = frozenset(((0, enrichment_parameters.EnrichmentParameters), (1, str), ("ep", enrichment_parameters.EnrichmentParameters), ("n", str)))
    _enrichment_enrichment_1_argtypes = frozenset(((0, str), ("n", str)))
    
    def __init__(self, *args, **kwargs):
        """Enrichment(self, n="")
        """
        types = set([(i, type(a)) for i, a in enumerate(args)])
        types.update([(k, type(v)) for k, v in kwargs.iteritems()])
        # vtable-like dispatch for exactly matching types
        if types <= self._enrichment_enrichment_1_argtypes:
            self._enrichment_enrichment_1(*args, **kwargs)
            return
        if types <= self._enrichment_enrichment_0_argtypes:
            self._enrichment_enrichment_0(*args, **kwargs)
            return
        # duck-typed dispatch based on whatever works!
        try:
            self._enrichment_enrichment_1(*args, **kwargs)
            return
        except (RuntimeError, TypeError, NameError):
            pass
        try:
            self._enrichment_enrichment_0(*args, **kwargs)
            return
        except (RuntimeError, TypeError, NameError):
            pass
        raise RuntimeError('method __init__() could not be dispatched')
    

    # attributes
    property M:
        """no docstring for M, please file a bug report!"""
        def __get__(self):
            return float((<cpp_enrichment.Enrichment *> self._inst).M)
    
        def __set__(self, value):
            (<cpp_enrichment.Enrichment *> self._inst).M = <double> value
    
    
    property M0:
        """This is the number of stripping stages initially guessed by the user."""
        def __get__(self):
            return float((<cpp_enrichment.Enrichment *> self._inst).M0)
    
        def __set__(self, value):
            (<cpp_enrichment.Enrichment *> self._inst).M0 = <double> value
    
    
    property Mstar:
        """The :math:`M^*` attribute represents the mass for which the adjusted
        stage separation factor, :math:`\\alpha^*_i`, is equal to one.  It is this
        value that is varied to achieve an optimized enrichment cascade.
        """
        def __get__(self):
            return float((<cpp_enrichment.Enrichment *> self._inst).Mstar)
    
        def __set__(self, value):
            (<cpp_enrichment.Enrichment *> self._inst).Mstar = <double> value
    
    
    property Mstar_0:
        """The :math:`M^*_0` represents a first guess at what the `Mstar` should be.
        The value of Mstar_0 on initialization should be in the ballpark
        of the optimized result of the Mstar attribute.  However, :math:`M^*_0` must
        always have a value between the weights of the j and k key components.
        """
        def __get__(self):
            return float((<cpp_enrichment.Enrichment *> self._inst).Mstar_0)
    
        def __set__(self, value):
            (<cpp_enrichment.Enrichment *> self._inst).Mstar_0 = <double> value
    
    
    property N:
        """no docstring for N, please file a bug report!"""
        def __get__(self):
            return float((<cpp_enrichment.Enrichment *> self._inst).N)
    
        def __set__(self, value):
            (<cpp_enrichment.Enrichment *> self._inst).N = <double> value
    
    
    property N0:
        """This is the number of enriching stages initially guessed by the user."""
        def __get__(self):
            return float((<cpp_enrichment.Enrichment *> self._inst).N0)
    
        def __set__(self, value):
            (<cpp_enrichment.Enrichment *> self._inst).N0 = <double> value
    
    
    property SWUperFeed:
        """This value denotes the number of separative work units (SWU) required
        per kg of feed for the specified cascade.
        """
        def __get__(self):
            return float((<cpp_enrichment.Enrichment *> self._inst).SWUperFeed)
    
        def __set__(self, value):
            (<cpp_enrichment.Enrichment *> self._inst).SWUperFeed = <double> value
    
    
    property SWUperProduct:
        """This value is the number of separative work units (SWU) required
        to produce 1 [kg] of product in the specified cascade.
        """
        def __get__(self):
            return float((<cpp_enrichment.Enrichment *> self._inst).SWUperProduct)
    
        def __set__(self, value):
            (<cpp_enrichment.Enrichment *> self._inst).SWUperProduct = <double> value
    
    
    property TotalPerFeed:
        """This represents the total flow rate of the cascade divided by the 
        feed flow rate.  As such, it shows the mass of material needed in the
        cascade to enrich an additional kilogram of feed.  Symbolically,
        the total flow rate is given as :math:`L` while the feed rate is
        :math:`F`.  Therefore, this quantity is sometimes seen as 'L-over-F'
        or as 'L/F'.  TotalPerFeed is the value that is minimized to form an 
        optimized cascade.
        """
        def __get__(self):
            return float((<cpp_enrichment.Enrichment *> self._inst).TotalPerFeed)
    
        def __set__(self, value):
            (<cpp_enrichment.Enrichment *> self._inst).TotalPerFeed = <double> value
    
    
    property alpha_0:
        """The :math:`\\alpha_0` attribute specifies the overall stage separation factor
        for the cascade.  This should be set on initialization.  Values should be
        greater than one.  Values less than one represent de-enrichment.
        """
        def __get__(self):
            return float((<cpp_enrichment.Enrichment *> self._inst).alpha_0)
    
        def __set__(self, value):
            (<cpp_enrichment.Enrichment *> self._inst).alpha_0 = <double> value
    
    
    property j:
        """This is an integer in zzaaam-form that represents the jth key component.
        This nuclide is preferentially enriched in the product stream.
        For standard uranium cascades j is 922350 (ie U-235).
        """
        def __get__(self):
            return int((<cpp_enrichment.Enrichment *> self._inst).j)
    
        def __set__(self, value):
            (<cpp_enrichment.Enrichment *> self._inst).j = nucname.zzaaam(value)
    
    
    property k:
        """This is an integer in zzaaam-form that represents the kth key component.
        This nuclide is preferentially enriched in the waste stream.
        For standard uranium cascades k is 922380 (ie U-238).
        """
        def __get__(self):
            return int((<cpp_enrichment.Enrichment *> self._inst).k)
    
        def __set__(self, value):
            (<cpp_enrichment.Enrichment *> self._inst).k = nucname.zzaaam(value)
    
    
    property mat_tail:
        """In addition to the mat_feed and mat_prod materials, Enrichment
        also has a tails or waste stream that is represented by this attribute.
        The mass of this material and the ms_prod product material should always 
        add up to the mass of the mat_feed feed stock.
        """
        def __get__(self):
            cdef material._Material mat_tail_proxy
            if self._mat_tail is None:
                mat_tail_proxy = material.Material(free_mat=False)
                mat_tail_proxy.mat_pointer = &(<cpp_enrichment.Enrichment *> self._inst).mat_tail
                self._mat_tail = mat_tail_proxy
            return self._mat_tail
    
        def __set__(self, value):
            cdef material._Material value_proxy
            value_proxy = material.Material(value, free_mat=not isinstance(value, material._Material))
            (<cpp_enrichment.Enrichment *> self._inst).mat_tail = value_proxy.mat_pointer[0]
            self._mat_tail = None
    
    
    property xP_j:
        """This is the target enrichment of the jth isotope in the
        product stream mat_prod.  The :math:`x^P_j` value is set by 
        the user at initialization or run-time.  For typical uranium 
        vectors, this value is about U-235 = 0.05.
        """
        def __get__(self):
            return float((<cpp_enrichment.Enrichment *> self._inst).xP_j)
    
        def __set__(self, value):
            (<cpp_enrichment.Enrichment *> self._inst).xP_j = <double> value
    
    
    property xW_j:
        """This is the target enrichment of the jth isotope in the
        waste stream ms_tail.  The :math:`x^W_j` value is set by the 
        user at initialization or runtime.  For typical uranium vectors,
        this value is about U-235 = 0.0025.
        """
        def __get__(self):
            return float((<cpp_enrichment.Enrichment *> self._inst).xW_j)
    
        def __set__(self, value):
            (<cpp_enrichment.Enrichment *> self._inst).xW_j = <double> value
    
    
    # methods
    def Comp2UnityOther(self):
        """Comp2UnityOther(self)
        no docstring for Comp2UnityOther, please file a bug report!"""
        (<cpp_enrichment.Enrichment *> self._inst).Comp2UnityOther()
    
    
    def Comp2UnitySecant(self):
        """Comp2UnitySecant(self)
        no docstring for Comp2UnitySecant, please file a bug report!"""
        (<cpp_enrichment.Enrichment *> self._inst).Comp2UnitySecant()
    
    
    def FindNM(self):
        """FindNM(self)
        no docstring for FindNM, please file a bug report!"""
        (<cpp_enrichment.Enrichment *> self._inst).FindNM()
    
    
    def LoverF(self):
        """LoverF(self)
        no docstring for LoverF, please file a bug report!"""
        (<cpp_enrichment.Enrichment *> self._inst).LoverF()
    
    
    def MstarOptimize(self):
        """MstarOptimize(self)
        no docstring for MstarOptimize, please file a bug report!"""
        (<cpp_enrichment.Enrichment *> self._inst).MstarOptimize()
    
    
    def PoverF(self, x_F, x_P, x_W):
        """PoverF(self, x_F, x_P, x_W)
        Solves for the product over feed enrichment ratio.
        
        .. math::
        
            \\frac{p}{f} = \\frac{(x_F - x_W)}{(x_P - x_W)}
        
        Parameters
        ----------
        x_F : float
            Feed enrichment.
        x_P : float
            Product enrichment.
        x_W : float
            Waste enrichment.
        
        Returns
        -------
        pfratio : float
            As calculated above.
        
        """
        cdef double rtnval
        rtnval = (<cpp_enrichment.Enrichment *> self._inst).PoverF(<double> x_F, <double> x_P, <double> x_W)
        return float(rtnval)
    
    
    def SolveNM(self):
        """SolveNM(self)
        no docstring for SolveNM, please file a bug report!"""
        (<cpp_enrichment.Enrichment *> self._inst).SolveNM()
    
    
    def WoverF(self, x_F, x_P, x_W):
        """WoverF(self, x_F, x_P, x_W)
        Solves for the waste over feed enrichment ratio.
        
        .. math::
        
            \\frac{p}{f} = \\frac{(x_F - x_P)}{(x_W - x_P)}
        
        Parameters
        ----------
        x_F : float
            Feed enrichment.
        x_P : float
            Product enrichment.
        x_W : float
            Waste enrichment.
        
        Returns
        -------
        wfratio : float
            As calculated above.
        
        """
        cdef double rtnval
        rtnval = (<cpp_enrichment.Enrichment *> self._inst).WoverF(<double> x_F, <double> x_P, <double> x_W)
        return float(rtnval)
    
    
    def _enrichment_calc_0(self):
        """calc(self)
        This method performs an optimization calculation on M* and solves for 
        appropriate values for all Enrichment attributes.  This includes the 
        product and waste streams flowing out of the the cascade as well.
        
        Parameters
        ----------
        input : dict or Material or None, optional
            If input is present, it is set as the component's mat_feed.  If input is 
            a nuclide mapping (zzaaam keys, float values), it is first converted into a 
            Material before being set as mat_feed.
        
        Returns
        -------
        output : Material
            mat_prod
        
        """
        cdef cpp_material.Material rtnval
        cdef material._Material rtnval_proxy
        rtnval = (<cpp_fccomp.FCComp *> self._inst).calc()
        rtnval_proxy = material.Material()
        rtnval_proxy.mat_pointer[0] = rtnval
        return rtnval_proxy
    
    
    def _enrichment_calc_1(self, incomp):
        """calc(self, incomp)
        This method performs an optimization calculation on M* and solves for 
        appropriate values for all Enrichment attributes.  This includes the 
        product and waste streams flowing out of the the cascade as well.
        
        Parameters
        ----------
        input : dict or Material or None, optional
            If input is present, it is set as the component's mat_feed.  If input is 
            a nuclide mapping (zzaaam keys, float values), it is first converted into a 
            Material before being set as mat_feed.
        
        Returns
        -------
        output : Material
            mat_prod
        
        """
        cdef pyne.stlcontainers._MapIntDouble incomp_proxy
        cdef cpp_material.Material rtnval
        cdef material._Material rtnval_proxy
        incomp_proxy = pyne.stlcontainers.MapIntDouble(incomp, not isinstance(incomp, pyne.stlcontainers._MapIntDouble))
        rtnval = (<cpp_fccomp.FCComp *> self._inst).calc(incomp_proxy.map_ptr[0])
        rtnval_proxy = material.Material()
        rtnval_proxy.mat_pointer[0] = rtnval
        return rtnval_proxy
    
    
    def _enrichment_calc_2(self, mat):
        """calc(self, mat)
        This method performs an optimization calculation on M* and solves for 
        appropriate values for all Enrichment attributes.  This includes the 
        product and waste streams flowing out of the the cascade as well.
        
        Parameters
        ----------
        input : dict or Material or None, optional
            If input is present, it is set as the component's mat_feed.  If input is 
            a nuclide mapping (zzaaam keys, float values), it is first converted into a 
            Material before being set as mat_feed.
        
        Returns
        -------
        output : Material
            mat_prod
        
        """
        cdef material._Material mat_proxy
        cdef cpp_material.Material rtnval
        cdef material._Material rtnval_proxy
        mat_proxy = material.Material(mat, free_mat=not isinstance(mat, material._Material))
        rtnval = (<cpp_fccomp.FCComp *> self._inst).calc(mat_proxy.mat_pointer[0])
        rtnval_proxy = material.Material()
        rtnval_proxy.mat_pointer[0] = rtnval
        return rtnval_proxy
    
    
    _enrichment_calc_0_argtypes = frozenset()
    _enrichment_calc_1_argtypes = frozenset(((0, pyne.stlcontainers.MapIntDouble), ("incomp", pyne.stlcontainers.MapIntDouble)))
    _enrichment_calc_2_argtypes = frozenset(((0, material.Material), ("mat", material.Material)))
    
    def calc(self, *args, **kwargs):
        """calc(self, mat)
        This method performs an optimization calculation on M* and solves for 
        appropriate values for all Enrichment attributes.  This includes the 
        product and waste streams flowing out of the the cascade as well.
        
        Parameters
        ----------
        input : dict or Material or None, optional
            If input is present, it is set as the component's mat_feed.  If input is 
            a nuclide mapping (zzaaam keys, float values), it is first converted into a 
            Material before being set as mat_feed.
        
        Returns
        -------
        output : Material
            mat_prod
        
        """
        types = set([(i, type(a)) for i, a in enumerate(args)])
        types.update([(k, type(v)) for k, v in kwargs.iteritems()])
        # vtable-like dispatch for exactly matching types
        if types <= self._enrichment_calc_0_argtypes:
            return self._enrichment_calc_0(*args, **kwargs)
        if types <= self._enrichment_calc_1_argtypes:
            return self._enrichment_calc_1(*args, **kwargs)
        if types <= self._enrichment_calc_2_argtypes:
            return self._enrichment_calc_2(*args, **kwargs)
        # duck-typed dispatch based on whatever works!
        try:
            return self._enrichment_calc_0(*args, **kwargs)
        except (RuntimeError, TypeError, NameError):
            pass
        try:
            return self._enrichment_calc_1(*args, **kwargs)
        except (RuntimeError, TypeError, NameError):
            pass
        try:
            return self._enrichment_calc_2(*args, **kwargs)
        except (RuntimeError, TypeError, NameError):
            pass
        raise RuntimeError('method calc() could not be dispatched')
    
    def calc_params(self):
        """calc_params(self)
        This sets the Enrichment parameters to the following 
        values::
        
            self.params_prior_calc["MassFeed"] = self.mat_feed.mass
            self.params_after_calc["MassFeed"] = 0.0
        
            self.params_prior_calc["MassProduct"] = 0.0
            self.params_after_calc["MassProduct"] = self.mat_prod.mass
        
            self.params_prior_calc["MassTails"] = 0.0
            self.params_after_calc["MassTails"] = self.mat_tail.mass
        
            self.params_prior_calc["N"] = self.N
            self.params_after_calc["N"] = self.N
        
            self.params_prior_calc["M"] = self.M
            self.params_after_calc["M"] = self.M
        
            self.params_prior_calc["Mstar"] = self.Mstar
            self.params_after_calc["Mstar"] = self.Mstar
        
            self.params_prior_calc["TotalPerFeed"] = self.TotalPerFeed
            self.params_after_calc["TotalPerFeed"] = self.TotalPerFeed
        
            self.params_prior_calc["SWUperFeed"] = self.SWUperFeed
            self.params_after_calc["SWUperFeed"] = 0.0
        
            self.params_prior_calc["SWUperProduct"] = 0.0
            self.params_after_calc["SWUperProduct"] = self.SWUperProduct
        
        """
        (<cpp_fccomp.FCComp *> self._inst).calc_params()
    
    
    def deltaU_i_OverG(self, i):
        """deltaU_i_OverG(self, i)
        no docstring for deltaU_i_OverG, please file a bug report!"""
        cdef double rtnval
        rtnval = (<cpp_enrichment.Enrichment *> self._inst).deltaU_i_OverG(i)
        return float(rtnval)
    
    
    def get_Ei(self, M_i):
        """get_Ei(self, M_i)
        no docstring for get_Ei, please file a bug report!"""
        cdef double rtnval
        rtnval = (<cpp_enrichment.Enrichment *> self._inst).get_Ei(<double> M_i)
        return float(rtnval)
    
    
    def get_Si(self, M_i):
        """get_Si(self, M_i)
        no docstring for get_Si, please file a bug report!"""
        cdef double rtnval
        rtnval = (<cpp_enrichment.Enrichment *> self._inst).get_Si(<double> M_i)
        return float(rtnval)
    
    
    def get_alphastar_i(self, M_i):
        """get_alphastar_i(self, M_i)
        no docstring for get_alphastar_i, please file a bug report!"""
        cdef double rtnval
        rtnval = (<cpp_enrichment.Enrichment *> self._inst).get_alphastar_i(<double> M_i)
        return float(rtnval)
    
    
    def initialize(self, ep):
        """initialize(self, ep)
        The initialize method takes an enrichment parameter object and sets
        the corresponding Enrichment attributes to the same value.
        
        Parameters
        ----------
        enrich_params : EnrichmentParameters
            A class containing the values to (re-)initialize an Enrichment cascade with.
        
        """
        cdef enrichment_parameters.EnrichmentParameters ep_proxy
        ep_proxy = <enrichment_parameters.EnrichmentParameters> ep
        (<cpp_enrichment.Enrichment *> self._inst).initialize((<cpp_enrichment_parameters.EnrichmentParameters *> ep_proxy._inst)[0])
    
    
    def xP_i(self, i):
        """xP_i(self, i)
        no docstring for xP_i, please file a bug report!"""
        cdef double rtnval
        rtnval = (<cpp_enrichment.Enrichment *> self._inst).xP_i(i)
        return float(rtnval)
    
    
    def xW_i(self, i):
        """xW_i(self, i)
        no docstring for xW_i, please file a bug report!"""
        cdef double rtnval
        rtnval = (<cpp_enrichment.Enrichment *> self._inst).xW_i(i)
        return float(rtnval)
    
    





