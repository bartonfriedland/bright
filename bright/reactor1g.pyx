################################################
#                 WARNING!                     #
# This file has been auto-generated by Bright. #
# Do not modify!!!                             #
#                                              #
#                                              #
#                    Come on, guys. I mean it! #
################################################
"""Python wrapper for reactor1g.
"""
cimport fccomp
cimport fluence_point
cimport numpy as np
cimport reactor_parameters
from bright cimport cpp_fccomp
from bright cimport cpp_fluence_point
from bright cimport cpp_reactor_parameters
from libcpp.map cimport map as cpp_map
from libcpp.set cimport set as cpp_set
from libcpp.string cimport string as std_string
from libcpp.vector cimport vector as cpp_vector
from pyne cimport cpp_material
from pyne cimport material
from pyne cimport stlconverters as conv

from pyne import material
from pyne import stlconverters as conv
import fccomp
import fluence_point
import numpy as np
import reactor_parameters

np.import_array()

cdef class Reactor1G(fccomp.FCComp):
    """One-Group Reactor Fuel Cycle Component Class.  Daughter of FCComp class.
    
    Parameters
    ----------
    rp : ReactorParameters, optional 
        A special data structure that contains information on how to setup and 
        run the reactor.
    paramtrack : set of str, optional 
        A set of strings that represents what parameter data the reactor should 
        store and set.  Different reactor types may have different characteristic 
        parameters of interest.
    n : str, optional 
        The name of the reactor fuel cycle component instance.
    
    Notes
    -----
    Some data members and functions have names that end in '_F_'.  This indicates 
    that these are a function of fluence, the time integral of the flux.  The '_Fd_' 
    suffix implies that the data is evaluated at the discharge fluence.
    
    """

    # constuctors
    def __cinit__(self, *args, **kwargs):
        self._inst = NULL
        self._free_inst = True

        # cached property defaults
        self._BU_F_ = None
        self._BUi_F_ = None
        self._D_F_ = None
        self._F = None
        self._Mj_F_ = None
        self._NiC = None
        self._NiF = None
        self._P_F_ = None
        self._SigmaCa_F_ = None
        self._SigmaCtr_F_ = None
        self._SigmaFa_F_ = None
        self._SigmaFtr_F_ = None
        self._coolant_chemical_form = None
        self._dC_F_ = None
        self._dF_F_ = None
        self._di_F_ = None
        self._fuel_chemical_form = None
        self._k_F_ = None
        self._kappaC_F_ = None
        self._kappaF_F_ = None
        self._lattice_E_F_ = None
        self._lattice_F_F_ = None
        self._mat_feed_act = None
        self._mat_feed_lan = None
        self._mat_feed_tru = None
        self._mat_feed_u = None
        self._mat_prod_act = None
        self._mat_prod_lan = None
        self._mat_prod_tru = None
        self._mat_prod_u = None
        self._miC = None
        self._miF = None
        self._niC = None
        self._niF = None
        self._pi_F_ = None
        self._zeta_F_ = None

    def _reactor1g_reactor1g_0(self, n=""):
        """Reactor1G(self, n="")
        """
        self._inst = new cpp_reactor1g.Reactor1G(std_string(<char *> n))
    
    
    def _reactor1g_reactor1g_1(self, paramtrack, n=""):
        """Reactor1G(self, paramtrack, n="")
        """
        cdef conv._SetStr paramtrack_proxy
        paramtrack_proxy = conv.SetStr(paramtrack, not isinstance(paramtrack, conv._SetStr))
        self._inst = new cpp_reactor1g.Reactor1G(paramtrack_proxy.set_ptr[0], std_string(<char *> n))
    
    
    def _reactor1g_reactor1g_2(self, rp, n=""):
        """Reactor1G(self, rp, n="")
        """
        cdef reactor_parameters.ReactorParameters rp_proxy
        rp_proxy = <reactor_parameters.ReactorParameters> rp
        self._inst = new cpp_reactor1g.Reactor1G((<cpp_reactor_parameters.ReactorParameters *> rp_proxy._inst)[0], std_string(<char *> n))
    
    
    def _reactor1g_reactor1g_3(self, rp, paramtrack, n=""):
        """Reactor1G(self, rp, paramtrack, n="")
        """
        cdef reactor_parameters.ReactorParameters rp_proxy
        cdef conv._SetStr paramtrack_proxy
        rp_proxy = <reactor_parameters.ReactorParameters> rp
        paramtrack_proxy = conv.SetStr(paramtrack, not isinstance(paramtrack, conv._SetStr))
        self._inst = new cpp_reactor1g.Reactor1G((<cpp_reactor_parameters.ReactorParameters *> rp_proxy._inst)[0], paramtrack_proxy.set_ptr[0], std_string(<char *> n))
    
    
    _reactor1g_reactor1g_0_argtypes = frozenset(((0, str), ("n", str)))
    _reactor1g_reactor1g_1_argtypes = frozenset(((0, conv.SetStr), (1, str), ("paramtrack", conv.SetStr), ("n", str)))
    _reactor1g_reactor1g_2_argtypes = frozenset(((0, reactor_parameters.ReactorParameters), (1, str), ("rp", reactor_parameters.ReactorParameters), ("n", str)))
    _reactor1g_reactor1g_3_argtypes = frozenset(((0, reactor_parameters.ReactorParameters), (1, conv.SetStr), (2, str), ("rp", reactor_parameters.ReactorParameters), ("paramtrack", conv.SetStr), ("n", str)))
    
    def __init__(self, *args, **kwargs):
        """Reactor1G(self, rp, paramtrack, n="")
        """
        types = set([(i, type(a)) for i, a in enumerate(args)])
        types.update([(k, type(v)) for k, v in kwargs.iteritems()])
        # vtable-like dispatch for exactly matching types
        if types <= self._reactor1g_reactor1g_0_argtypes:
            self._reactor1g_reactor1g_0(*args, **kwargs)
            return
        if types <= self._reactor1g_reactor1g_1_argtypes:
            self._reactor1g_reactor1g_1(*args, **kwargs)
            return
        if types <= self._reactor1g_reactor1g_2_argtypes:
            self._reactor1g_reactor1g_2(*args, **kwargs)
            return
        if types <= self._reactor1g_reactor1g_3_argtypes:
            self._reactor1g_reactor1g_3(*args, **kwargs)
            return
        # duck-typed dispatch based on whatever works!
        try:
            self._reactor1g_reactor1g_0(*args, **kwargs)
            return
        except (RuntimeError, TypeError, NameError):
            pass
        try:
            self._reactor1g_reactor1g_1(*args, **kwargs)
            return
        except (RuntimeError, TypeError, NameError):
            pass
        try:
            self._reactor1g_reactor1g_2(*args, **kwargs)
            return
        except (RuntimeError, TypeError, NameError):
            pass
        try:
            self._reactor1g_reactor1g_3(*args, **kwargs)
            return
        except (RuntimeError, TypeError, NameError):
            pass
        raise RuntimeError('method __init__() could not be dispatched')
    

    # attributes
    property A_IHM:
        """The atomic weight of the initial heavy metal (float)."""
        def __get__(self):
            return float((<cpp_reactor1g.Reactor1G *> self._inst).A_IHM)
    
        def __set__(self, value):
            (<cpp_reactor1g.Reactor1G *> self._inst).A_IHM = <double> value
    
    
    property B:
        """This integer is the total number of batches in the fuel management scheme.  
        B is typically indexed by b."""
        def __get__(self):
            return int((<cpp_reactor1g.Reactor1G *> self._inst).B)
    
        def __set__(self, value):
            (<cpp_reactor1g.Reactor1G *> self._inst).B = value
    
    
    property BU_F_:
        """The reactor burnup [MWd/kgIHM] as a function of fluence.  This is the linear
        combination of ``BUi_F_`` for all initial nuclides using miF as weights."""
        def __get__(self):
            cdef np.ndarray BU_F__proxy
            cdef np.npy_intp BU_F__proxy_shape[1]
            if self._BU_F_ is None:
                BU_F__proxy_shape[0] = <np.npy_intp> (<cpp_reactor1g.Reactor1G *> self._inst).BU_F_.size()
                BU_F__proxy = np.PyArray_SimpleNewFromData(1, BU_F__proxy_shape, np.NPY_FLOAT64, &(<cpp_reactor1g.Reactor1G *> self._inst).BU_F_[0])
                self._BU_F_ = BU_F__proxy
            return self._BU_F_
    
        def __set__(self, value):
            cdef cpp_vector[double] value_proxy
            cdef int i
            cdef int value_size = len(value)
            cdef double * value_data
            if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
                value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = value_data[i]
            else:
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = <double> value[i]
            (<cpp_reactor1g.Reactor1G *> self._inst).BU_F_ = value_proxy
            self._BU_F_ = None
    
    
    property BUd:
        """The discharge burnup [MWd/kgIHM] (float).  Unless something went very wrong,
        this should be rather close in value to target_BU."""
        def __get__(self):
            return float((<cpp_reactor1g.Reactor1G *> self._inst).BUd)
    
        def __set__(self, value):
            (<cpp_reactor1g.Reactor1G *> self._inst).BUd = <double> value
    
    
    property BUi_F_:
        """The burnup of each initial isotope in the core as a function of fluence.  
        This is a dictionary whose keys are initial nuclides and whose values are 
        vectors of floats.  This data has units of [MWd/kgIHM] and is read in from 
        libfile.
        """
        def __get__(self):
            cdef conv._MapIntVectorDouble BUi_F__proxy
            if self._BUi_F_ is None:
                BUi_F__proxy = conv.MapIntVectorDouble(False, False)
                BUi_F__proxy.map_ptr = &(<cpp_reactor1g.Reactor1G *> self._inst).BUi_F_
                self._BUi_F_ = BUi_F__proxy
            return self._BUi_F_
    
        def __set__(self, value):
            cdef conv._MapIntVectorDouble value_proxy
            value_proxy = conv.MapIntVectorDouble(value, not isinstance(value, conv._MapIntVectorDouble))
            (<cpp_reactor1g.Reactor1G *> self._inst).BUi_F_ = value_proxy.map_ptr[0]
            self._BUi_F_ = None
    
    
    property D_F_:
        """The full-core neutron destruction rate [n/s] a function of fluence.  This is the
        sum of ``dF_F_`` and ``dC_F_``."""
        def __get__(self):
            cdef np.ndarray D_F__proxy
            cdef np.npy_intp D_F__proxy_shape[1]
            if self._D_F_ is None:
                D_F__proxy_shape[0] = <np.npy_intp> (<cpp_reactor1g.Reactor1G *> self._inst).D_F_.size()
                D_F__proxy = np.PyArray_SimpleNewFromData(1, D_F__proxy_shape, np.NPY_FLOAT64, &(<cpp_reactor1g.Reactor1G *> self._inst).D_F_[0])
                self._D_F_ = D_F__proxy
            return self._D_F_
    
        def __set__(self, value):
            cdef cpp_vector[double] value_proxy
            cdef int i
            cdef int value_size = len(value)
            cdef double * value_data
            if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
                value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = value_data[i]
            else:
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = <double> value[i]
            (<cpp_reactor1g.Reactor1G *> self._inst).D_F_ = value_proxy
            self._D_F_ = None
    
    
    property F:
        """The fluence points that the reactor library is based on.  This is a vector of 
        floats that have units [n/kb].  This is read in from libfile.
        """
        def __get__(self):
            cdef np.ndarray F_proxy
            cdef np.npy_intp F_proxy_shape[1]
            if self._F is None:
                F_proxy_shape[0] = <np.npy_intp> (<cpp_reactor1g.Reactor1G *> self._inst).F.size()
                F_proxy = np.PyArray_SimpleNewFromData(1, F_proxy_shape, np.NPY_FLOAT64, &(<cpp_reactor1g.Reactor1G *> self._inst).F[0])
                self._F = F_proxy
            return self._F
    
        def __set__(self, value):
            cdef cpp_vector[double] value_proxy
            cdef int i
            cdef int value_size = len(value)
            cdef double * value_data
            if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
                value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = value_data[i]
            else:
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = <double> value[i]
            (<cpp_reactor1g.Reactor1G *> self._inst).F = value_proxy
            self._F = None
    
    
    property Fd:
        """The discharge fluence [n/kb] (float).  May be used to calculate the amount 
        of time that the fuel was irradiated."""
        def __get__(self):
            return float((<cpp_reactor1g.Reactor1G *> self._inst).Fd)
    
        def __set__(self, value):
            (<cpp_reactor1g.Reactor1G *> self._inst).Fd = <double> value
    
    
    property MWC:
        """The molecular weight of the coolant (float)."""
        def __get__(self):
            return float((<cpp_reactor1g.Reactor1G *> self._inst).MWC)
    
        def __set__(self, value):
            (<cpp_reactor1g.Reactor1G *> self._inst).MWC = <double> value
    
    
    property MWF:
        """The molecular weight of the fuel (float)."""
        def __get__(self):
            return float((<cpp_reactor1g.Reactor1G *> self._inst).MWF)
    
        def __set__(self, value):
            (<cpp_reactor1g.Reactor1G *> self._inst).MWF = <double> value
    
    
    property Mj_F_:
        """The transmutation matrix of the fuel (specifically, mat_feed) into the jth nuclide 
        as a function of fluence.  Used with the discharge fluence Fd to calculate mat_prod.  
        This object is therefore a dictionary from zzaaam-integers to vectors of floats."""
        def __get__(self):
            cdef conv._MapIntVectorDouble Mj_F__proxy
            if self._Mj_F_ is None:
                Mj_F__proxy = conv.MapIntVectorDouble(False, False)
                Mj_F__proxy.map_ptr = &(<cpp_reactor1g.Reactor1G *> self._inst).Mj_F_
                self._Mj_F_ = Mj_F__proxy
            return self._Mj_F_
    
        def __set__(self, value):
            cdef conv._MapIntVectorDouble value_proxy
            value_proxy = conv.MapIntVectorDouble(value, not isinstance(value, conv._MapIntVectorDouble))
            (<cpp_reactor1g.Reactor1G *> self._inst).Mj_F_ = value_proxy.map_ptr[0]
            self._Mj_F_ = None
    
    
    property NiC:
        """Number density of the coolant as a function of initial nuclide.  
        Map with zzaaam-integer keys and float values."""
        def __get__(self):
            cdef conv._MapIntDouble NiC_proxy
            if self._NiC is None:
                NiC_proxy = conv.MapIntDouble(False, False)
                NiC_proxy.map_ptr = &(<cpp_reactor1g.Reactor1G *> self._inst).NiC
                self._NiC = NiC_proxy
            return self._NiC
    
        def __set__(self, value):
            cdef conv._MapIntDouble value_proxy
            value_proxy = conv.MapIntDouble(value, not isinstance(value, conv._MapIntDouble))
            (<cpp_reactor1g.Reactor1G *> self._inst).NiC = value_proxy.map_ptr[0]
            self._NiC = None
    
    
    property NiF:
        """Number density of the fuel as a function of initial nuclide.  
        Map with zzaaam-integer keys and float values."""
        def __get__(self):
            cdef conv._MapIntDouble NiF_proxy
            if self._NiF is None:
                NiF_proxy = conv.MapIntDouble(False, False)
                NiF_proxy.map_ptr = &(<cpp_reactor1g.Reactor1G *> self._inst).NiF
                self._NiF = NiF_proxy
            return self._NiF
    
        def __set__(self, value):
            cdef conv._MapIntDouble value_proxy
            value_proxy = conv.MapIntDouble(value, not isinstance(value, conv._MapIntDouble))
            (<cpp_reactor1g.Reactor1G *> self._inst).NiF = value_proxy.map_ptr[0]
            self._NiF = None
    
    
    property P_F_:
        """The full-core neutron production rate [n/s] as a function of fluence.  
        This is the linear combination of ``pi_F_`` for all initial nuclides using miF 
        as weights. (Note: the coolant does not have a production rate). The linear 
        combination is subsequently multiplied by the non-leakage probability, P_NL, 
        before being assigned to ``P_F_``."""
        def __get__(self):
            cdef np.ndarray P_F__proxy
            cdef np.npy_intp P_F__proxy_shape[1]
            if self._P_F_ is None:
                P_F__proxy_shape[0] = <np.npy_intp> (<cpp_reactor1g.Reactor1G *> self._inst).P_F_.size()
                P_F__proxy = np.PyArray_SimpleNewFromData(1, P_F__proxy_shape, np.NPY_FLOAT64, &(<cpp_reactor1g.Reactor1G *> self._inst).P_F_[0])
                self._P_F_ = P_F__proxy
            return self._P_F_
    
        def __set__(self, value):
            cdef cpp_vector[double] value_proxy
            cdef int i
            cdef int value_size = len(value)
            cdef double * value_data
            if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
                value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = value_data[i]
            else:
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = <double> value[i]
            (<cpp_reactor1g.Reactor1G *> self._inst).P_F_ = value_proxy
            self._P_F_ = None
    
    
    property P_NL:
        """The reactor's non-leakage probability (float).  This is often used as a 
        calibration parameter.
        """
        def __get__(self):
            return float((<cpp_reactor1g.Reactor1G *> self._inst).P_NL)
    
        def __set__(self, value):
            (<cpp_reactor1g.Reactor1G *> self._inst).P_NL = <double> value
    
    
    property S_O:
        """The number of slots (float) in a fuel assembly that are open.  Thus this 
        is the number of slots that do not contain a fuel pin and are instead filled 
        in by coolant.
        """
        def __get__(self):
            return float((<cpp_reactor1g.Reactor1G *> self._inst).S_O)
    
        def __set__(self, value):
            (<cpp_reactor1g.Reactor1G *> self._inst).S_O = <double> value
    
    
    property S_T:
        """The total number of fuel pin slots (float) in a fuel assembly.  For a 17x17 
        bundle this is 289.0.
        """
        def __get__(self):
            return float((<cpp_reactor1g.Reactor1G *> self._inst).S_T)
    
        def __set__(self, value):
            (<cpp_reactor1g.Reactor1G *> self._inst).S_T = <double> value
    
    
    property SigmaCa_F_:
        """The coolant macroscopic absorption cross section [1/cm]."""
        def __get__(self):
            cdef np.ndarray SigmaCa_F__proxy
            cdef np.npy_intp SigmaCa_F__proxy_shape[1]
            if self._SigmaCa_F_ is None:
                SigmaCa_F__proxy_shape[0] = <np.npy_intp> (<cpp_reactor1g.Reactor1G *> self._inst).SigmaCa_F_.size()
                SigmaCa_F__proxy = np.PyArray_SimpleNewFromData(1, SigmaCa_F__proxy_shape, np.NPY_FLOAT64, &(<cpp_reactor1g.Reactor1G *> self._inst).SigmaCa_F_[0])
                self._SigmaCa_F_ = SigmaCa_F__proxy
            return self._SigmaCa_F_
    
        def __set__(self, value):
            cdef cpp_vector[double] value_proxy
            cdef int i
            cdef int value_size = len(value)
            cdef double * value_data
            if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
                value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = value_data[i]
            else:
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = <double> value[i]
            (<cpp_reactor1g.Reactor1G *> self._inst).SigmaCa_F_ = value_proxy
            self._SigmaCa_F_ = None
    
    
    property SigmaCtr_F_:
        """The coolant macroscopic transport cross section [1/cm]."""
        def __get__(self):
            cdef np.ndarray SigmaCtr_F__proxy
            cdef np.npy_intp SigmaCtr_F__proxy_shape[1]
            if self._SigmaCtr_F_ is None:
                SigmaCtr_F__proxy_shape[0] = <np.npy_intp> (<cpp_reactor1g.Reactor1G *> self._inst).SigmaCtr_F_.size()
                SigmaCtr_F__proxy = np.PyArray_SimpleNewFromData(1, SigmaCtr_F__proxy_shape, np.NPY_FLOAT64, &(<cpp_reactor1g.Reactor1G *> self._inst).SigmaCtr_F_[0])
                self._SigmaCtr_F_ = SigmaCtr_F__proxy
            return self._SigmaCtr_F_
    
        def __set__(self, value):
            cdef cpp_vector[double] value_proxy
            cdef int i
            cdef int value_size = len(value)
            cdef double * value_data
            if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
                value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = value_data[i]
            else:
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = <double> value[i]
            (<cpp_reactor1g.Reactor1G *> self._inst).SigmaCtr_F_ = value_proxy
            self._SigmaCtr_F_ = None
    
    
    property SigmaFa_F_:
        """The fuel macroscopic absorption cross section [1/cm]."""
        def __get__(self):
            cdef np.ndarray SigmaFa_F__proxy
            cdef np.npy_intp SigmaFa_F__proxy_shape[1]
            if self._SigmaFa_F_ is None:
                SigmaFa_F__proxy_shape[0] = <np.npy_intp> (<cpp_reactor1g.Reactor1G *> self._inst).SigmaFa_F_.size()
                SigmaFa_F__proxy = np.PyArray_SimpleNewFromData(1, SigmaFa_F__proxy_shape, np.NPY_FLOAT64, &(<cpp_reactor1g.Reactor1G *> self._inst).SigmaFa_F_[0])
                self._SigmaFa_F_ = SigmaFa_F__proxy
            return self._SigmaFa_F_
    
        def __set__(self, value):
            cdef cpp_vector[double] value_proxy
            cdef int i
            cdef int value_size = len(value)
            cdef double * value_data
            if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
                value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = value_data[i]
            else:
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = <double> value[i]
            (<cpp_reactor1g.Reactor1G *> self._inst).SigmaFa_F_ = value_proxy
            self._SigmaFa_F_ = None
    
    
    property SigmaFtr_F_:
        """The fuel macroscopic transport cross section [1/cm]."""
        def __get__(self):
            cdef np.ndarray SigmaFtr_F__proxy
            cdef np.npy_intp SigmaFtr_F__proxy_shape[1]
            if self._SigmaFtr_F_ is None:
                SigmaFtr_F__proxy_shape[0] = <np.npy_intp> (<cpp_reactor1g.Reactor1G *> self._inst).SigmaFtr_F_.size()
                SigmaFtr_F__proxy = np.PyArray_SimpleNewFromData(1, SigmaFtr_F__proxy_shape, np.NPY_FLOAT64, &(<cpp_reactor1g.Reactor1G *> self._inst).SigmaFtr_F_[0])
                self._SigmaFtr_F_ = SigmaFtr_F__proxy
            return self._SigmaFtr_F_
    
        def __set__(self, value):
            cdef cpp_vector[double] value_proxy
            cdef int i
            cdef int value_size = len(value)
            cdef double * value_data
            if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
                value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = value_data[i]
            else:
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = <double> value[i]
            (<cpp_reactor1g.Reactor1G *> self._inst).SigmaFtr_F_ = value_proxy
            self._SigmaFtr_F_ = None
    
    
    property VC:
        """The relative coolant region volume."""
        def __get__(self):
            return float((<cpp_reactor1g.Reactor1G *> self._inst).VC)
    
        def __set__(self, value):
            (<cpp_reactor1g.Reactor1G *> self._inst).VC = <double> value
    
    
    property VF:
        """The relative fuel region volume."""
        def __get__(self):
            return float((<cpp_reactor1g.Reactor1G *> self._inst).VF)
    
        def __set__(self, value):
            (<cpp_reactor1g.Reactor1G *> self._inst).VF = <double> value
    
    
    property coolant_chemical_form:
        """This is the chemical form of coolant as a dictionary or other mapping.  
        This uses the same notation as fuel_form except that "IHM" is no longer 
        a valid key.  The term 'coolant' is used in preference over the term 
        'moderator' because not all reactors moderate neutrons.  For example, 
        LWRs often cool the reactor core with borated water::
        
            ReactorParamters.coolant_form = {}
        
            ReactorParamters.coolant_form["H1"]  = 2.0
            ReactorParamters.coolant_form["O16"] = 1.0
            ReactorParamters.coolant_form["B10"] = 0.199 * 550 * 10.0**-6
            ReactorParamters.coolant_form["B11"] = 0.801 * 550 * 10.0**-6
        
        """
        def __get__(self):
            cdef conv._MapStrDouble coolant_chemical_form_proxy
            if self._coolant_chemical_form is None:
                coolant_chemical_form_proxy = conv.MapStrDouble(False, False)
                coolant_chemical_form_proxy.map_ptr = &(<cpp_reactor1g.Reactor1G *> self._inst).coolant_chemical_form
                self._coolant_chemical_form = coolant_chemical_form_proxy
            return self._coolant_chemical_form
    
        def __set__(self, value):
            cdef conv._MapStrDouble value_proxy
            value_proxy = conv.MapStrDouble(value, not isinstance(value, conv._MapStrDouble))
            (<cpp_reactor1g.Reactor1G *> self._inst).coolant_chemical_form = value_proxy.map_ptr[0]
            self._coolant_chemical_form = None
    
    
    property dC_F_:
        """The neutron destruction rate [n/s] of the coolant as a function of fluence.  
        This is the linear combination of ``di_F_`` for all initial nuclides using miC 
        as weights.  If the disadvantage factor is used, then ``zeta_F_`` is multiplied 
        by the linear combination before being assigned to ``dC_F_``."""
        def __get__(self):
            cdef np.ndarray dC_F__proxy
            cdef np.npy_intp dC_F__proxy_shape[1]
            if self._dC_F_ is None:
                dC_F__proxy_shape[0] = <np.npy_intp> (<cpp_reactor1g.Reactor1G *> self._inst).dC_F_.size()
                dC_F__proxy = np.PyArray_SimpleNewFromData(1, dC_F__proxy_shape, np.NPY_FLOAT64, &(<cpp_reactor1g.Reactor1G *> self._inst).dC_F_[0])
                self._dC_F_ = dC_F__proxy
            return self._dC_F_
    
        def __set__(self, value):
            cdef cpp_vector[double] value_proxy
            cdef int i
            cdef int value_size = len(value)
            cdef double * value_data
            if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
                value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = value_data[i]
            else:
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = <double> value[i]
            (<cpp_reactor1g.Reactor1G *> self._inst).dC_F_ = value_proxy
            self._dC_F_ = None
    
    
    property dF_F_:
        """The neutron destruction rate [n/s] of the fuel as a function of fluence.  
        This is the linear combination of ``di_F_`` for all initial nuclides using miF 
        as weights."""
        def __get__(self):
            cdef np.ndarray dF_F__proxy
            cdef np.npy_intp dF_F__proxy_shape[1]
            if self._dF_F_ is None:
                dF_F__proxy_shape[0] = <np.npy_intp> (<cpp_reactor1g.Reactor1G *> self._inst).dF_F_.size()
                dF_F__proxy = np.PyArray_SimpleNewFromData(1, dF_F__proxy_shape, np.NPY_FLOAT64, &(<cpp_reactor1g.Reactor1G *> self._inst).dF_F_[0])
                self._dF_F_ = dF_F__proxy
            return self._dF_F_
    
        def __set__(self, value):
            cdef cpp_vector[double] value_proxy
            cdef int i
            cdef int value_size = len(value)
            cdef double * value_data
            if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
                value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = value_data[i]
            else:
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = <double> value[i]
            (<cpp_reactor1g.Reactor1G *> self._inst).dF_F_ = value_proxy
            self._dF_F_ = None
    
    
    property deltaR:
        """The :math:`\delta R` value of the core with the current mat_feed.  This is equal 
        to the production rate minus the destruction rate at the target burnup::
        
            deltaR = batch_average(target_BU, "P") - batch_average(target_BU, "D")
        
        This is computed via the calc_deltaR() method."""
        def __get__(self):
            return float((<cpp_reactor1g.Reactor1G *> self._inst).deltaR)
    
        def __set__(self, value):
            (<cpp_reactor1g.Reactor1G *> self._inst).deltaR = <double> value
    
    
    property di_F_:
        """The neutron destruction rate of each initial isotope in the core as a function 
        of fluence. This is a dictionary whose keys are initial nuclides and whose values 
        are vectors of floats.  This data has units of [n/s] and is read in from libfile.
        """
        def __get__(self):
            cdef conv._MapIntVectorDouble di_F__proxy
            if self._di_F_ is None:
                di_F__proxy = conv.MapIntVectorDouble(False, False)
                di_F__proxy.map_ptr = &(<cpp_reactor1g.Reactor1G *> self._inst).di_F_
                self._di_F_ = di_F__proxy
            return self._di_F_
    
        def __set__(self, value):
            cdef conv._MapIntVectorDouble value_proxy
            value_proxy = conv.MapIntVectorDouble(value, not isinstance(value, conv._MapIntVectorDouble))
            (<cpp_reactor1g.Reactor1G *> self._inst).di_F_ = value_proxy.map_ptr[0]
            self._di_F_ = None
    
    
    property fd:
        """The lower index of the discharge fluence (int)."""
        def __get__(self):
            return int((<cpp_reactor1g.Reactor1G *> self._inst).fd)
    
        def __set__(self, value):
            (<cpp_reactor1g.Reactor1G *> self._inst).fd = value
    
    
    property fuel_chemical_form:
        """This is the chemical form of fuel as a dictionary or other mapping.  Keys are 
        often strings that represent isotopes while values represent the corresponding 
        mass weights.  The heavy metal concentration by the key "IHM".  
        This will automatically fill in the nuclides in mat_feed for the "IHM" weight.  
        For example, LWRs typically use a UOX fuel form::
        
            Reactor1G.fuel_chemical_form = {"IHM": 1.0, "O16": 2.0}
        
        """
        def __get__(self):
            cdef conv._MapStrDouble fuel_chemical_form_proxy
            if self._fuel_chemical_form is None:
                fuel_chemical_form_proxy = conv.MapStrDouble(False, False)
                fuel_chemical_form_proxy.map_ptr = &(<cpp_reactor1g.Reactor1G *> self._inst).fuel_chemical_form
                self._fuel_chemical_form = fuel_chemical_form_proxy
            return self._fuel_chemical_form
    
        def __set__(self, value):
            cdef conv._MapStrDouble value_proxy
            value_proxy = conv.MapStrDouble(value, not isinstance(value, conv._MapStrDouble))
            (<cpp_reactor1g.Reactor1G *> self._inst).fuel_chemical_form = value_proxy.map_ptr[0]
            self._fuel_chemical_form = None
    
    
    property k:
        """This is the multiplication factor of the reactor at discharge.  This should 
        be very close in value to 1.0."""
        def __get__(self):
            return float((<cpp_reactor1g.Reactor1G *> self._inst).k)
    
        def __set__(self, value):
            (<cpp_reactor1g.Reactor1G *> self._inst).k = <double> value
    
    
    property k_F_:
        """The multiplication factor of the core.  Calculated from ``P_F_`` divided by 
        ``D_F_``.  This attribute is unitless and not often used."""
        def __get__(self):
            cdef np.ndarray k_F__proxy
            cdef np.npy_intp k_F__proxy_shape[1]
            if self._k_F_ is None:
                k_F__proxy_shape[0] = <np.npy_intp> (<cpp_reactor1g.Reactor1G *> self._inst).k_F_.size()
                k_F__proxy = np.PyArray_SimpleNewFromData(1, k_F__proxy_shape, np.NPY_FLOAT64, &(<cpp_reactor1g.Reactor1G *> self._inst).k_F_[0])
                self._k_F_ = k_F__proxy
            return self._k_F_
    
        def __set__(self, value):
            cdef cpp_vector[double] value_proxy
            cdef int i
            cdef int value_size = len(value)
            cdef double * value_data
            if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
                value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = value_data[i]
            else:
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = <double> value[i]
            (<cpp_reactor1g.Reactor1G *> self._inst).k_F_ = value_proxy
            self._k_F_ = None
    
    
    property kappaC_F_:
        """One over the thermal diffusion length of the coolant [1/cm]."""
        def __get__(self):
            cdef np.ndarray kappaC_F__proxy
            cdef np.npy_intp kappaC_F__proxy_shape[1]
            if self._kappaC_F_ is None:
                kappaC_F__proxy_shape[0] = <np.npy_intp> (<cpp_reactor1g.Reactor1G *> self._inst).kappaC_F_.size()
                kappaC_F__proxy = np.PyArray_SimpleNewFromData(1, kappaC_F__proxy_shape, np.NPY_FLOAT64, &(<cpp_reactor1g.Reactor1G *> self._inst).kappaC_F_[0])
                self._kappaC_F_ = kappaC_F__proxy
            return self._kappaC_F_
    
        def __set__(self, value):
            cdef cpp_vector[double] value_proxy
            cdef int i
            cdef int value_size = len(value)
            cdef double * value_data
            if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
                value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = value_data[i]
            else:
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = <double> value[i]
            (<cpp_reactor1g.Reactor1G *> self._inst).kappaC_F_ = value_proxy
            self._kappaC_F_ = None
    
    
    property kappaF_F_:
        """One over the thermal diffusion length of the fuel [1/cm]."""
        def __get__(self):
            cdef np.ndarray kappaF_F__proxy
            cdef np.npy_intp kappaF_F__proxy_shape[1]
            if self._kappaF_F_ is None:
                kappaF_F__proxy_shape[0] = <np.npy_intp> (<cpp_reactor1g.Reactor1G *> self._inst).kappaF_F_.size()
                kappaF_F__proxy = np.PyArray_SimpleNewFromData(1, kappaF_F__proxy_shape, np.NPY_FLOAT64, &(<cpp_reactor1g.Reactor1G *> self._inst).kappaF_F_[0])
                self._kappaF_F_ = kappaF_F__proxy
            return self._kappaF_F_
    
        def __set__(self, value):
            cdef cpp_vector[double] value_proxy
            cdef int i
            cdef int value_size = len(value)
            cdef double * value_data
            if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
                value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = value_data[i]
            else:
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = <double> value[i]
            (<cpp_reactor1g.Reactor1G *> self._inst).kappaF_F_ = value_proxy
            self._kappaF_F_ = None
    
    
    property l:
        """The pitch or length (float) of the unit fuel pin cell [cm]."""
        def __get__(self):
            return float((<cpp_reactor1g.Reactor1G *> self._inst).l)
    
        def __set__(self, value):
            (<cpp_reactor1g.Reactor1G *> self._inst).l = <double> value
    
    
    property lattice_E_F_:
        """The lattice function E(F)."""
        def __get__(self):
            cdef np.ndarray lattice_E_F__proxy
            cdef np.npy_intp lattice_E_F__proxy_shape[1]
            if self._lattice_E_F_ is None:
                lattice_E_F__proxy_shape[0] = <np.npy_intp> (<cpp_reactor1g.Reactor1G *> self._inst).lattice_E_F_.size()
                lattice_E_F__proxy = np.PyArray_SimpleNewFromData(1, lattice_E_F__proxy_shape, np.NPY_FLOAT64, &(<cpp_reactor1g.Reactor1G *> self._inst).lattice_E_F_[0])
                self._lattice_E_F_ = lattice_E_F__proxy
            return self._lattice_E_F_
    
        def __set__(self, value):
            cdef cpp_vector[double] value_proxy
            cdef int i
            cdef int value_size = len(value)
            cdef double * value_data
            if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
                value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = value_data[i]
            else:
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = <double> value[i]
            (<cpp_reactor1g.Reactor1G *> self._inst).lattice_E_F_ = value_proxy
            self._lattice_E_F_ = None
    
    
    property lattice_F_F_:
        """The lattice function F(F)."""
        def __get__(self):
            cdef np.ndarray lattice_F_F__proxy
            cdef np.npy_intp lattice_F_F__proxy_shape[1]
            if self._lattice_F_F_ is None:
                lattice_F_F__proxy_shape[0] = <np.npy_intp> (<cpp_reactor1g.Reactor1G *> self._inst).lattice_F_F_.size()
                lattice_F_F__proxy = np.PyArray_SimpleNewFromData(1, lattice_F_F__proxy_shape, np.NPY_FLOAT64, &(<cpp_reactor1g.Reactor1G *> self._inst).lattice_F_F_[0])
                self._lattice_F_F_ = lattice_F_F__proxy
            return self._lattice_F_F_
    
        def __set__(self, value):
            cdef cpp_vector[double] value_proxy
            cdef int i
            cdef int value_size = len(value)
            cdef double * value_data
            if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
                value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = value_data[i]
            else:
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = <double> value[i]
            (<cpp_reactor1g.Reactor1G *> self._inst).lattice_F_F_ = value_proxy
            self._lattice_F_F_ = None
    
    
    property lattice_flag:
        """Flag (str) that represents what lattice type the fuel assemblies are arranged in.  
        Currently accepted values are "Planar", "Spherical", and "Cylindrical"."""
        def __get__(self):
            return str(<char *> (<cpp_reactor1g.Reactor1G *> self._inst).lattice_flag.c_str())
    
        def __set__(self, value):
            (<cpp_reactor1g.Reactor1G *> self._inst).lattice_flag = std_string(<char *> value)
    
    
    property libfile:
        """The path (str) to the reactor data library; usually something like "LWR.h5" 
        or "FR.h5".
        """
        def __get__(self):
            return str(<char *> (<cpp_reactor1g.Reactor1G *> self._inst).libfile.c_str())
    
        def __set__(self, value):
            (<cpp_reactor1g.Reactor1G *> self._inst).libfile = std_string(<char *> value)
    
    
    property mat_feed_act:
        """The input actininide material, mat_feed.sub_act()."""
        def __get__(self):
            cdef material._Material mat_feed_act_proxy
            if self._mat_feed_act is None:
                mat_feed_act_proxy = material.Material(free_mat=False)
                mat_feed_act_proxy.mat_pointer = &(<cpp_reactor1g.Reactor1G *> self._inst).mat_feed_act
                self._mat_feed_act = mat_feed_act_proxy
            return self._mat_feed_act
    
        def __set__(self, value):
            cdef material._Material value_proxy
            value_proxy = material.Material(value, free_mat=not isinstance(value, material._Material))
            (<cpp_reactor1g.Reactor1G *> self._inst).mat_feed_act = value_proxy.mat_pointer[0]
            self._mat_feed_act = None
    
    
    property mat_feed_lan:
        """The input lanthanide material, mat_feed.sub_lan()."""
        def __get__(self):
            cdef material._Material mat_feed_lan_proxy
            if self._mat_feed_lan is None:
                mat_feed_lan_proxy = material.Material(free_mat=False)
                mat_feed_lan_proxy.mat_pointer = &(<cpp_reactor1g.Reactor1G *> self._inst).mat_feed_lan
                self._mat_feed_lan = mat_feed_lan_proxy
            return self._mat_feed_lan
    
        def __set__(self, value):
            cdef material._Material value_proxy
            value_proxy = material.Material(value, free_mat=not isinstance(value, material._Material))
            (<cpp_reactor1g.Reactor1G *> self._inst).mat_feed_lan = value_proxy.mat_pointer[0]
            self._mat_feed_lan = None
    
    
    property mat_feed_tru:
        """The input transuranic material, mat_feed.sub_tru()."""
        def __get__(self):
            cdef material._Material mat_feed_tru_proxy
            if self._mat_feed_tru is None:
                mat_feed_tru_proxy = material.Material(free_mat=False)
                mat_feed_tru_proxy.mat_pointer = &(<cpp_reactor1g.Reactor1G *> self._inst).mat_feed_tru
                self._mat_feed_tru = mat_feed_tru_proxy
            return self._mat_feed_tru
    
        def __set__(self, value):
            cdef material._Material value_proxy
            value_proxy = material.Material(value, free_mat=not isinstance(value, material._Material))
            (<cpp_reactor1g.Reactor1G *> self._inst).mat_feed_tru = value_proxy.mat_pointer[0]
            self._mat_feed_tru = None
    
    
    property mat_feed_u:
        """The input uranium material, mat_feed.sub_u()."""
        def __get__(self):
            cdef material._Material mat_feed_u_proxy
            if self._mat_feed_u is None:
                mat_feed_u_proxy = material.Material(free_mat=False)
                mat_feed_u_proxy.mat_pointer = &(<cpp_reactor1g.Reactor1G *> self._inst).mat_feed_u
                self._mat_feed_u = mat_feed_u_proxy
            return self._mat_feed_u
    
        def __set__(self, value):
            cdef material._Material value_proxy
            value_proxy = material.Material(value, free_mat=not isinstance(value, material._Material))
            (<cpp_reactor1g.Reactor1G *> self._inst).mat_feed_u = value_proxy.mat_pointer[0]
            self._mat_feed_u = None
    
    
    property mat_prod_act:
        """The output actininide material, mat_prod.sub_act()."""
        def __get__(self):
            cdef material._Material mat_prod_act_proxy
            if self._mat_prod_act is None:
                mat_prod_act_proxy = material.Material(free_mat=False)
                mat_prod_act_proxy.mat_pointer = &(<cpp_reactor1g.Reactor1G *> self._inst).mat_prod_act
                self._mat_prod_act = mat_prod_act_proxy
            return self._mat_prod_act
    
        def __set__(self, value):
            cdef material._Material value_proxy
            value_proxy = material.Material(value, free_mat=not isinstance(value, material._Material))
            (<cpp_reactor1g.Reactor1G *> self._inst).mat_prod_act = value_proxy.mat_pointer[0]
            self._mat_prod_act = None
    
    
    property mat_prod_lan:
        """The output lanthanide material, mat_prod.sub_lan()."""
        def __get__(self):
            cdef material._Material mat_prod_lan_proxy
            if self._mat_prod_lan is None:
                mat_prod_lan_proxy = material.Material(free_mat=False)
                mat_prod_lan_proxy.mat_pointer = &(<cpp_reactor1g.Reactor1G *> self._inst).mat_prod_lan
                self._mat_prod_lan = mat_prod_lan_proxy
            return self._mat_prod_lan
    
        def __set__(self, value):
            cdef material._Material value_proxy
            value_proxy = material.Material(value, free_mat=not isinstance(value, material._Material))
            (<cpp_reactor1g.Reactor1G *> self._inst).mat_prod_lan = value_proxy.mat_pointer[0]
            self._mat_prod_lan = None
    
    
    property mat_prod_tru:
        """The output transuranic material, mat_prod.sub_tru()."""
        def __get__(self):
            cdef material._Material mat_prod_tru_proxy
            if self._mat_prod_tru is None:
                mat_prod_tru_proxy = material.Material(free_mat=False)
                mat_prod_tru_proxy.mat_pointer = &(<cpp_reactor1g.Reactor1G *> self._inst).mat_prod_tru
                self._mat_prod_tru = mat_prod_tru_proxy
            return self._mat_prod_tru
    
        def __set__(self, value):
            cdef material._Material value_proxy
            value_proxy = material.Material(value, free_mat=not isinstance(value, material._Material))
            (<cpp_reactor1g.Reactor1G *> self._inst).mat_prod_tru = value_proxy.mat_pointer[0]
            self._mat_prod_tru = None
    
    
    property mat_prod_u:
        """The output urnaium material, mat_prod.sub_u()."""
        def __get__(self):
            cdef material._Material mat_prod_u_proxy
            if self._mat_prod_u is None:
                mat_prod_u_proxy = material.Material(free_mat=False)
                mat_prod_u_proxy.mat_pointer = &(<cpp_reactor1g.Reactor1G *> self._inst).mat_prod_u
                self._mat_prod_u = mat_prod_u_proxy
            return self._mat_prod_u
    
        def __set__(self, value):
            cdef material._Material value_proxy
            value_proxy = material.Material(value, free_mat=not isinstance(value, material._Material))
            (<cpp_reactor1g.Reactor1G *> self._inst).mat_prod_u = value_proxy.mat_pointer[0]
            self._mat_prod_u = None
    
    
    property miC:
        """Mass weight of the coolant as a function of initial nuclide.  
        Map with zzaaam-integer keys and float values."""
        def __get__(self):
            cdef conv._MapIntDouble miC_proxy
            if self._miC is None:
                miC_proxy = conv.MapIntDouble(False, False)
                miC_proxy.map_ptr = &(<cpp_reactor1g.Reactor1G *> self._inst).miC
                self._miC = miC_proxy
            return self._miC
    
        def __set__(self, value):
            cdef conv._MapIntDouble value_proxy
            value_proxy = conv.MapIntDouble(value, not isinstance(value, conv._MapIntDouble))
            (<cpp_reactor1g.Reactor1G *> self._inst).miC = value_proxy.map_ptr[0]
            self._miC = None
    
    
    property miF:
        """Mass weight of the fuel as a function of initial nuclide.  
        Map with zzaaam-integer keys and float values."""
        def __get__(self):
            cdef conv._MapIntDouble miF_proxy
            if self._miF is None:
                miF_proxy = conv.MapIntDouble(False, False)
                miF_proxy.map_ptr = &(<cpp_reactor1g.Reactor1G *> self._inst).miF
                self._miF = miF_proxy
            return self._miF
    
        def __set__(self, value):
            cdef conv._MapIntDouble value_proxy
            value_proxy = conv.MapIntDouble(value, not isinstance(value, conv._MapIntDouble))
            (<cpp_reactor1g.Reactor1G *> self._inst).miF = value_proxy.map_ptr[0]
            self._miF = None
    
    
    property niC:
        """Atomic number weight of the coolant as a function of initial nuclide.  
        Map with zzaaam-integer keys and float values."""
        def __get__(self):
            cdef conv._MapIntDouble niC_proxy
            if self._niC is None:
                niC_proxy = conv.MapIntDouble(False, False)
                niC_proxy.map_ptr = &(<cpp_reactor1g.Reactor1G *> self._inst).niC
                self._niC = niC_proxy
            return self._niC
    
        def __set__(self, value):
            cdef conv._MapIntDouble value_proxy
            value_proxy = conv.MapIntDouble(value, not isinstance(value, conv._MapIntDouble))
            (<cpp_reactor1g.Reactor1G *> self._inst).niC = value_proxy.map_ptr[0]
            self._niC = None
    
    
    property niF:
        """Atomic number weight of the fuel as a function of initial nuclide. 
        Map with zzaaam-integer keys and float values."""
        def __get__(self):
            cdef conv._MapIntDouble niF_proxy
            if self._niF is None:
                niF_proxy = conv.MapIntDouble(False, False)
                niF_proxy.map_ptr = &(<cpp_reactor1g.Reactor1G *> self._inst).niF
                self._niF = niF_proxy
            return self._niF
    
        def __set__(self, value):
            cdef conv._MapIntDouble value_proxy
            value_proxy = conv.MapIntDouble(value, not isinstance(value, conv._MapIntDouble))
            (<cpp_reactor1g.Reactor1G *> self._inst).niF = value_proxy.map_ptr[0]
            self._niF = None
    
    
    property phi:
        """The nominal flux value (float) that the library for this reactor type was 
        generated with.  Used to correctly weight batch-specific fluxes.
        """
        def __get__(self):
            return float((<cpp_reactor1g.Reactor1G *> self._inst).phi)
    
        def __set__(self, value):
            (<cpp_reactor1g.Reactor1G *> self._inst).phi = <double> value
    
    
    property pi_F_:
        """The neutron production rate of each initial isotope in the core as a function 
        of fluence.  This is a dictionary whose keys are initial nuclides and whose values 
        are vectors of floats.  This data has units of [neutrons/seconds] (abbr [n/s]) is 
        read in from libfile."""
        def __get__(self):
            cdef conv._MapIntVectorDouble pi_F__proxy
            if self._pi_F_ is None:
                pi_F__proxy = conv.MapIntVectorDouble(False, False)
                pi_F__proxy.map_ptr = &(<cpp_reactor1g.Reactor1G *> self._inst).pi_F_
                self._pi_F_ = pi_F__proxy
            return self._pi_F_
    
        def __set__(self, value):
            cdef conv._MapIntVectorDouble value_proxy
            value_proxy = conv.MapIntVectorDouble(value, not isinstance(value, conv._MapIntVectorDouble))
            (<cpp_reactor1g.Reactor1G *> self._inst).pi_F_ = value_proxy.map_ptr[0]
            self._pi_F_ = None
    
    
    property r:
        """The radius (float) of the fuel region [cm]."""
        def __get__(self):
            return float((<cpp_reactor1g.Reactor1G *> self._inst).r)
    
        def __set__(self, value):
            (<cpp_reactor1g.Reactor1G *> self._inst).r = <double> value
    
    
    property rescale_hydrogen_xs:
        """Boolean to determine whether the reactor should rescale the Hydrogen-1 
        destruction rate in the coolant as a function of fluence.  The scaling factor is 
        calculated via the following equation:
        
            .. math:: f(F) = 1.36927 - 0.01119 \cdot BU(F)
        
        This is typically not done for fast reactors but is a useful correction for LWRs.
        """
        def __get__(self):
            return bool((<cpp_reactor1g.Reactor1G *> self._inst).rescale_hydrogen_xs)
    
        def __set__(self, value):
            (<cpp_reactor1g.Reactor1G *> self._inst).rescale_hydrogen_xs = <bint> value
    
    
    property rhoC:
        """The coolant region density.  A float in units of [g/cm^3]."""
        def __get__(self):
            return float((<cpp_reactor1g.Reactor1G *> self._inst).rhoC)
    
        def __set__(self, value):
            (<cpp_reactor1g.Reactor1G *> self._inst).rhoC = <double> value
    
    
    property rhoF:
        """The fuel region density.  A float in units of [g/cm^3]."""
        def __get__(self):
            return float((<cpp_reactor1g.Reactor1G *> self._inst).rhoF)
    
        def __set__(self, value):
            (<cpp_reactor1g.Reactor1G *> self._inst).rhoF = <double> value
    
    
    property target_BU:
        """The reactor's target discharge burnup (float).  This is given 
        in units of [MWd/kgIHM].  Often the actual discharge burnup BUd does not 
        quite hit this value, but comes acceptably close."""
        def __get__(self):
            return float((<cpp_reactor1g.Reactor1G *> self._inst).target_BU)
    
        def __set__(self, value):
            (<cpp_reactor1g.Reactor1G *> self._inst).target_BU = <double> value
    
    
    property tru_cr:
        """The transuranic conversion ratio of the reactor (float).  
        This is set via the calc_tru_cr() method."""
        def __get__(self):
            return float((<cpp_reactor1g.Reactor1G *> self._inst).tru_cr)
    
        def __set__(self, value):
            (<cpp_reactor1g.Reactor1G *> self._inst).tru_cr = <double> value
    
    
    property use_zeta:
        """Boolaean to determine whether the thermal disadvantage factor is employed or not.  
        LWRs typically set this as True while FRs have a False value."""
        def __get__(self):
            return bool((<cpp_reactor1g.Reactor1G *> self._inst).use_zeta)
    
        def __set__(self, value):
            (<cpp_reactor1g.Reactor1G *> self._inst).use_zeta = <bint> value
    
    
    property zeta_F_:
        """The thermal disadvantage factor as a function of fluence.  This attribute is 
        unitless and is set when calc_zeta is called."""
        def __get__(self):
            cdef np.ndarray zeta_F__proxy
            cdef np.npy_intp zeta_F__proxy_shape[1]
            if self._zeta_F_ is None:
                zeta_F__proxy_shape[0] = <np.npy_intp> (<cpp_reactor1g.Reactor1G *> self._inst).zeta_F_.size()
                zeta_F__proxy = np.PyArray_SimpleNewFromData(1, zeta_F__proxy_shape, np.NPY_FLOAT64, &(<cpp_reactor1g.Reactor1G *> self._inst).zeta_F_[0])
                self._zeta_F_ = zeta_F__proxy
            return self._zeta_F_
    
        def __set__(self, value):
            cdef cpp_vector[double] value_proxy
            cdef int i
            cdef int value_size = len(value)
            cdef double * value_data
            if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
                value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = value_data[i]
            else:
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = <double> value[i]
            (<cpp_reactor1g.Reactor1G *> self._inst).zeta_F_ = value_proxy
            self._zeta_F_ = None
    
    
    # methods
    def BUd_bisection_method(self):
        """BUd_bisection_method(self)
        Calculates the maximum discharge burnup via the Bisection Method for a 
        given mat_feed in this reactor.  This iterates over values of BUd to find 
        a batch averaged multiplication factor that is closest to 1.0.
        
        Other root finding methods for determining maximum discharge burnup are 
        certainly possible.
        """
        (<cpp_reactor1g.Reactor1G *> self._inst).BUd_bisection_method()
    
    
    def batch_average(self, BUd, PDk_flag="K"):
        """batch_average(self, BUd, PDk_flag="K")
        Finds the batch-averaged P(F), D(F), or k(F) when at discharge burnup BUd.
        This function is typically iterated over until a BUd is found such that 
        k(F) = 1.0 + err.
        
        Parameters
        ----------
        BUd : float
            The discharge burnup [MWd/kgIHM] to obtain a batch-averaged value for.
        PDk_flag : str , optional
            Flag that determines whether the neutron production rate "P" [n/s],  
            the neutron destruction rate "D" [n/s], or the multiplication factor 
            "K" is reported in the output.
        
        Returns
        -------
        PDk : float 
            The batch averaged neutron production rate, neutron destruction rate, 
            or the multiplication factor as determined by the input flag.
        
        """
        cdef double rtnval
        rtnval = (<cpp_reactor1g.Reactor1G *> self._inst).batch_average(<double> BUd, std_string(<char *> PDk_flag))
        return float(rtnval)
    
    
    def batch_average_k(self, BUd):
        """batch_average_k(self, BUd)
        no docstring for batch_average_k, please file a bug report!"""
        cdef double rtnval
        rtnval = (<cpp_reactor1g.Reactor1G *> self._inst).batch_average_k(<double> BUd)
        return float(rtnval)
    
    
    def _reactor1g_calc_0(self):
        """calc(self)
        no docstring for calc, please file a bug report!"""
        cdef cpp_material.Material rtnval
        cdef material._Material rtnval_proxy
        rtnval = (<cpp_fccomp.FCComp *> self._inst).calc()
        rtnval_proxy = material.Material()
        rtnval_proxy.mat_pointer[0] = rtnval
        return rtnval_proxy
    
    
    def _reactor1g_calc_1(self, incomp):
        """calc(self, incomp)
        no docstring for calc, please file a bug report!"""
        cdef conv._MapIntDouble incomp_proxy
        cdef cpp_material.Material rtnval
        cdef material._Material rtnval_proxy
        incomp_proxy = conv.MapIntDouble(incomp, not isinstance(incomp, conv._MapIntDouble))
        rtnval = (<cpp_fccomp.FCComp *> self._inst).calc(incomp_proxy.map_ptr[0])
        rtnval_proxy = material.Material()
        rtnval_proxy.mat_pointer[0] = rtnval
        return rtnval_proxy
    
    
    def _reactor1g_calc_2(self, mat):
        """calc(self, mat)
        no docstring for calc, please file a bug report!"""
        cdef material._Material mat_proxy
        cdef cpp_material.Material rtnval
        cdef material._Material rtnval_proxy
        mat_proxy = material.Material(mat, free_mat=not isinstance(mat, material._Material))
        rtnval = (<cpp_fccomp.FCComp *> self._inst).calc(mat_proxy.mat_pointer[0])
        rtnval_proxy = material.Material()
        rtnval_proxy.mat_pointer[0] = rtnval
        return rtnval_proxy
    
    
    _reactor1g_calc_0_argtypes = frozenset()
    _reactor1g_calc_1_argtypes = frozenset(((0, conv.MapIntDouble), ("incomp", conv.MapIntDouble)))
    _reactor1g_calc_2_argtypes = frozenset(((0, material.Material), ("mat", material.Material)))
    
    def calc(self, *args, **kwargs):
        """calc(self, mat)
        no docstring for calc, please file a bug report!"""
        types = set([(i, type(a)) for i, a in enumerate(args)])
        types.update([(k, type(v)) for k, v in kwargs.iteritems()])
        # vtable-like dispatch for exactly matching types
        if types <= self._reactor1g_calc_0_argtypes:
            return self._reactor1g_calc_0(*args, **kwargs)
        if types <= self._reactor1g_calc_1_argtypes:
            return self._reactor1g_calc_1(*args, **kwargs)
        if types <= self._reactor1g_calc_2_argtypes:
            return self._reactor1g_calc_2(*args, **kwargs)
        # duck-typed dispatch based on whatever works!
        try:
            return self._reactor1g_calc_0(*args, **kwargs)
        except (RuntimeError, TypeError, NameError):
            pass
        try:
            return self._reactor1g_calc_1(*args, **kwargs)
        except (RuntimeError, TypeError, NameError):
            pass
        try:
            return self._reactor1g_calc_2(*args, **kwargs)
        except (RuntimeError, TypeError, NameError):
            pass
        raise RuntimeError('method calc() could not be dispatched')
    
    def calc_Mj_F_(self):
        """calc_Mj_F_(self)
        This function calculates and sets the ``Mj_F_`` attribute from mat_feed and the 
        raw reactor data ``Tij_F_``.
        """
        (<cpp_reactor1g.Reactor1G *> self._inst).calc_Mj_F_()
    
    
    def calc_Mj_Fd_(self):
        """calc_Mj_Fd_(self)
        This function evaluates ``Mj_F_`` calculated from calc_Mj_F_() at the 
        discharge fluence Fd. The resultant isotopic dictionary is then converted 
        into the mat_prod mass stream for this pass through the reactor.  Thus if 
        ever you need to calculate mat_prod without going through calc(), use this 
        function.
        """
        (<cpp_reactor1g.Reactor1G *> self._inst).calc_Mj_Fd_()
    
    
    def _reactor1g_calc_deltar_0(self):
        """calc_deltaR(self)
        Calculates and sets the deltaR value of the reactor.  This is equal to the 
        production rate minus the destruction rate at the target burnup::
        
            deltaR = batch_average(target_BU, "P") - batch_average(target_BU, "D")
        
        Parameters
        ----------
        input : dict or Material or None, optional 
            If input is present, it set as the component's mat_feed.  If input is a 
            isotopic dictionary (zzaaam keys, float values), this dictionary is first 
            converted into a Material before being set as mat_feed.
        
        Returns
        -------
        deltaR : float 
            deltaR value
        """
        cdef double rtnval
        rtnval = (<cpp_reactor1g.Reactor1G *> self._inst).calc_deltaR()
        return float(rtnval)
    
    
    def _reactor1g_calc_deltar_1(self, incomp):
        """calc_deltaR(self, incomp)
        Calculates and sets the deltaR value of the reactor.  This is equal to the 
        production rate minus the destruction rate at the target burnup::
        
            deltaR = batch_average(target_BU, "P") - batch_average(target_BU, "D")
        
        Parameters
        ----------
        input : dict or Material or None, optional 
            If input is present, it set as the component's mat_feed.  If input is a 
            isotopic dictionary (zzaaam keys, float values), this dictionary is first 
            converted into a Material before being set as mat_feed.
        
        Returns
        -------
        deltaR : float 
            deltaR value
        """
        cdef conv._MapIntDouble incomp_proxy
        cdef double rtnval
        incomp_proxy = conv.MapIntDouble(incomp, not isinstance(incomp, conv._MapIntDouble))
        rtnval = (<cpp_reactor1g.Reactor1G *> self._inst).calc_deltaR(incomp_proxy.map_ptr[0])
        return float(rtnval)
    
    
    def _reactor1g_calc_deltar_2(self, mat):
        """calc_deltaR(self, mat)
        Calculates and sets the deltaR value of the reactor.  This is equal to the 
        production rate minus the destruction rate at the target burnup::
        
            deltaR = batch_average(target_BU, "P") - batch_average(target_BU, "D")
        
        Parameters
        ----------
        input : dict or Material or None, optional 
            If input is present, it set as the component's mat_feed.  If input is a 
            isotopic dictionary (zzaaam keys, float values), this dictionary is first 
            converted into a Material before being set as mat_feed.
        
        Returns
        -------
        deltaR : float 
            deltaR value
        """
        cdef material._Material mat_proxy
        cdef double rtnval
        mat_proxy = material.Material(mat, free_mat=not isinstance(mat, material._Material))
        rtnval = (<cpp_reactor1g.Reactor1G *> self._inst).calc_deltaR(mat_proxy.mat_pointer[0])
        return float(rtnval)
    
    
    _reactor1g_calc_deltar_0_argtypes = frozenset()
    _reactor1g_calc_deltar_1_argtypes = frozenset(((0, conv.MapIntDouble), ("incomp", conv.MapIntDouble)))
    _reactor1g_calc_deltar_2_argtypes = frozenset(((0, material.Material), ("mat", material.Material)))
    
    def calc_deltaR(self, *args, **kwargs):
        """calc_deltaR(self, mat)
        Calculates and sets the deltaR value of the reactor.  This is equal to the 
        production rate minus the destruction rate at the target burnup::
        
            deltaR = batch_average(target_BU, "P") - batch_average(target_BU, "D")
        
        Parameters
        ----------
        input : dict or Material or None, optional 
            If input is present, it set as the component's mat_feed.  If input is a 
            isotopic dictionary (zzaaam keys, float values), this dictionary is first 
            converted into a Material before being set as mat_feed.
        
        Returns
        -------
        deltaR : float 
            deltaR value
        """
        types = set([(i, type(a)) for i, a in enumerate(args)])
        types.update([(k, type(v)) for k, v in kwargs.iteritems()])
        # vtable-like dispatch for exactly matching types
        if types <= self._reactor1g_calc_deltar_0_argtypes:
            return self._reactor1g_calc_deltar_0(*args, **kwargs)
        if types <= self._reactor1g_calc_deltar_1_argtypes:
            return self._reactor1g_calc_deltar_1(*args, **kwargs)
        if types <= self._reactor1g_calc_deltar_2_argtypes:
            return self._reactor1g_calc_deltar_2(*args, **kwargs)
        # duck-typed dispatch based on whatever works!
        try:
            return self._reactor1g_calc_deltar_0(*args, **kwargs)
        except (RuntimeError, TypeError, NameError):
            pass
        try:
            return self._reactor1g_calc_deltar_1(*args, **kwargs)
        except (RuntimeError, TypeError, NameError):
            pass
        try:
            return self._reactor1g_calc_deltar_2(*args, **kwargs)
        except (RuntimeError, TypeError, NameError):
            pass
        raise RuntimeError('method calc_deltaR() could not be dispatched')
    
    def calc_mat_prod(self):
        """calc_mat_prod(self)
        This is a convenience function that wraps the transmutation matrix methods.  
        It is equivalent to::
        
            #Wrapper to calculate discharge isotopics.
            calc_Mj_F_()
            calc_Mj_Fd_()
        
        """
        (<cpp_reactor1g.Reactor1G *> self._inst).calc_mat_prod()
    
    
    def calc_sub_mats(self):
        """calc_sub_mats(self)
        This sets possibly relevant reactor input and output sub-materials.  
        Specifically, it computes the attributes:
        
            * mat_feed_u
            * mat_feed_tru
            * mat_feed_lan
            * mat_feed_act
            * mat_prod_u
            * mat_prod_tru
            * mat_prod_lan
            * mat_prod_act
        
        """
        (<cpp_reactor1g.Reactor1G *> self._inst).calc_sub_mats()
    
    
    def calc_tru_cr(self):
        """calc_tru_cr(self)
        This calculates and sets the transuranic conversion ratio tru_cr through 
        the equation:
        
        .. math:: 
        
            \mbox{tru\_cr} = 1.0 - \frac{\mbox{mat\_feed\_tru.mass} - \mbox{mat\_prod\_tru.mass}}{\frac{\mbox{BUd}}{935.0}}
        
        Returns
        -------
        tru_cr : float) 
            The value of the transuranic conversion ratio just calculated.
        
        """
        cdef double rtnval
        rtnval = (<cpp_reactor1g.Reactor1G *> self._inst).calc_tru_cr()
        return float(rtnval)
    
    
    def calc_zeta(self):
        """calc_zeta(self)
        This calculates the thermal disadvantage factor for the geometry 
        specified by lattice_flag.  The results are set to ``zeta_F_``.  
        This is ostensibly done via the methodology detailed in Lamarsh's 
        `Nuclear Reactor Theory <http://www.amazon.com/Introduction-Nuclear-Reactor-Theory-Lamarsh/dp/0894480405>`_.
        
        Unfortunately, this formulation for the disadvantage factor is **only** valid 
        in the case where a << b! Often times, modern (thermal) reactors do not satisfy 
        this requirement.  We instead have a 'thin moderator' situation.
        
        To fix this problem properly requires going to a multi-region diffusion/transport 
        calculation.  Doing so is beyond the scope of Bright at this time and certainly 
        beyond the aspirations of a one-group methodology.  A strategy that is more 
        in-line with current practice is to use the results of a more sophisticated method, 
        interpolate over them, and use them here.
        
        Thus in the case where 0.1 < VF/VC, where the fuel is greater than 10% of 
        the coolant, the above strategy is what is implemented. A baseline disadvantage 
        factor is determined from data presented in "*Thermal disadvantage factor 
        calculation by the multi-region collision probability method*" by B. Ozgener, 
        and H. A. Ozgener, Institute of Nuclear Energy, Istanbul Technical University 
        80626 Maslak, Istanbul, Turkey, Received 28 January 2003; accepted 20 May 2003. 
        Available online 6 March 2004.  This baseline value happens to be a function of VF/VC.
        
        The Lamarsh method is then used as a scaling factor on the baseline function to
        account for variations in fuel composition and fluence.
        """
        (<cpp_reactor1g.Reactor1G *> self._inst).calc_zeta()
    
    
    def calc_zeta_cylindrical(self):
        """calc_zeta_cylindrical(self)
        This calculates the thermal disadvantage factor for a clyindrical geometry. 
        """
        (<cpp_reactor1g.Reactor1G *> self._inst).calc_zeta_cylindrical()
    
    
    def calc_zeta_planar(self):
        """calc_zeta_planar(self)
        This calculates the thermal disadvantage factor for a planar geometry.  
        The results are set to ``zeta_F_``.
        """
        (<cpp_reactor1g.Reactor1G *> self._inst).calc_zeta_planar()
    
    
    def calc_zeta_spherical(self):
        """calc_zeta_spherical(self)
        This calculates the thermal disadvantage factor for a spherical geometry.
        """
        (<cpp_reactor1g.Reactor1G *> self._inst).calc_zeta_spherical()
    
    
    def calibrate_P_NL_to_BUd(self):
        """calibrate_P_NL_to_BUd(self)
        Often times the non-leakage probability of a reactor is not known, though 
        the input isotopics and the target discharge burnup are.  This function handles 
        that situation by calibrating the non-leakage probability of this reactor P_NL 
        to hit its target burnup target_BU. Such a calibration proceeds by bisection 
        method as well.  This function is extremely useful for benchmarking calculations.
        """
        (<cpp_reactor1g.Reactor1G *> self._inst).calibrate_P_NL_to_BUd()
    
    
    def fluence_at_BU(self, BU):
        """fluence_at_BU(self, BU)
        This function takes a burnup value  and returns a special fluence point object.  
        The fluence point is an amalgamation of data where the at which the burnup occurs.
        This object instance FP contains three pieces of information::
            
            FP.f    #Index immediately lower than where BU achieved (int)
            FP.F    #Fluence value itself (float)
            FP.m    #Slope dBU/dF between points f and f+1 (double)
        
        Parameters
        ----------
        burnup : float 
            Burnup [MWd/kgIHM] at which to calculate the corresponding fluence.
        
        Returns
        -------
        fp : FluencePoint 
            A class containing fluence information.
        
        """
        cdef cpp_fluence_point.FluencePoint rtnval
        cdef fluence_point.FluencePoint rtnval_proxy
        rtnval = (<cpp_reactor1g.Reactor1G *> self._inst).fluence_at_BU(<double> BU)
        rtnval_proxy = fluence_point.FluencePoint()
        (<cpp_fluence_point.FluencePoint *> rtnval_proxy._inst)[0] = rtnval
        return rtnval_proxy
    
    
    def fold_mass_weights(self):
        """fold_mass_weights(self)
        This method performs the all-important task of doing the isotopically-weighted 
        linear combination of raw data.  In a very real sense this is what makes this 
        reactor *this specific reactor*.  The weights are taken as the values of mat_feed.  
        The raw data must have previously been read in from loadlib().  
        
        Warnings
        --------
        Anytime any reactor parameter whatsoever (mat_feed, P_NL, *etc*) is altered in 
        any way, the fold_mass_weights() function must be called to reset all of the 
        resultant data. If you are unsure, please call this function anyway to be safe.  
        There is no harm in calling this method multiple times.
        
        """
        (<cpp_reactor1g.Reactor1G *> self._inst).fold_mass_weights()
    
    
    def initialize(self, rp):
        """initialize(self, rp)
        The initialize() method for reactors copies all of the reactor specific 
        parameters to this instance. Additionally, it calculates and sets the volumes 
        VF and VC.
        
        Parameters
        ----------
        reactor_parameters : ReactorParameters 
            A special data structure that contains information on how to setup and 
            run the reactor.
        
        """
        cdef reactor_parameters.ReactorParameters rp_proxy
        rp_proxy = <reactor_parameters.ReactorParameters> rp
        (<cpp_reactor1g.Reactor1G *> self._inst).initialize((<cpp_reactor_parameters.ReactorParameters *> rp_proxy._inst)[0])
    
    
    def lattice_E_cylindrical(self, a, b):
        """lattice_E_cylindrical(self, a, b)
        Calculates the lattice function E(F) for cylindrical geometry.  
        
        Parameters
        ----------
        a : float 
            Fuel region radius equivalent [cm].
        b : float 
            Unit fuel cell pitch length equivalent [cm].
        
        """
        (<cpp_reactor1g.Reactor1G *> self._inst).lattice_E_cylindrical(<double> a, <double> b)
    
    
    def lattice_E_planar(self, a, b):
        """lattice_E_planar(self, a, b)
        Calculates the lattice function E(F) for planar geometry.  
        
        Parameters
        ----------
        a : float 
            Fuel region radius equivalent [cm].
        b : float 
            Unit fuel cell pitch length equivalent [cm].
        
        """
        (<cpp_reactor1g.Reactor1G *> self._inst).lattice_E_planar(<double> a, <double> b)
    
    
    def lattice_E_spherical(self, a, b):
        """lattice_E_spherical(self, a, b)
        Calculates the lattice function E(F) for spherical geometry.  
        
        Parameters
        ----------
        a : float 
            Fuel region radius equivalent [cm].
        b : float 
            Unit fuel cell pitch length equivalent [cm].
        
        """
        (<cpp_reactor1g.Reactor1G *> self._inst).lattice_E_spherical(<double> a, <double> b)
    
    
    def lattice_F_cylindrical(self, a, b):
        """lattice_F_cylindrical(self, a, b)
        Calculates the lattice function F(F) for cylindrical geometry.  
        
        Parameters
        ----------
        a : float 
            Fuel region radius equivalent [cm].
        b : float 
            Unit fuel cell pitch length equivalent [cm].
        
        """
        (<cpp_reactor1g.Reactor1G *> self._inst).lattice_F_cylindrical(<double> a, <double> b)
    
    
    def lattice_F_planar(self, a, b):
        """lattice_F_planar(self, a, b)
        Calculates the lattice function F(F) for planar geometry.
        
        Parameters
        ----------
        a : float 
            Fuel region radius equivalent [cm].
        b : float 
            Unit fuel cell pitch length equivalent [cm].
        
        """
        (<cpp_reactor1g.Reactor1G *> self._inst).lattice_F_planar(<double> a, <double> b)
    
    
    def lattice_F_spherical(self, a, b):
        """lattice_F_spherical(self, a, b)
        Calculates the lattice function F(F) for spherical geometry.  
        
        Parameters
        ----------
        a : float 
            Fuel region radius equivalent [cm].
        b : float 
            Unit fuel cell pitch length equivalent [cm].
        
        """
        (<cpp_reactor1g.Reactor1G *> self._inst).lattice_F_spherical(<double> a, <double> b)
    
    
    def loadlib(self, lib="Reactor.h5"):
        """loadlib(self, lib="Reactor.h5")
        This method finds the HDF5 library for this reactor and extracts the necessary 
        information from it. This method is typically called by the constructor of the 
        child reactor type object.  It must be called before attempting to do any real 
        computation.
        
        Parameters
        ----------
        lib : str 
            Path to the reactor library.
        
        """
        (<cpp_reactor1g.Reactor1G *> self._inst).loadlib(std_string(<char *> lib))
    
    
    def run_P_NL(self, temp_pnl):
        """run_P_NL(self, temp_pnl)
        Performs a reactor run for a specific non-leakage probability value.
        This requires that mat_feed be (meaningfully) set and is for use with 
        calibrate_P_NL_to_BUd().
        
        This function amounts to the following code::
        
            self.P_NL = pnl
            self.fold_mass_weights()
            self.BUd_bisection_method()
        
        Parameters
        ----------
        pnl : float 
            The new non-leakage probability for the reactor.
        
        """
        (<cpp_reactor1g.Reactor1G *> self._inst).run_P_NL(<double> temp_pnl)
    
    


