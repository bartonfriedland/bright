################################################
#                 WARNING!                     #
# This file has been auto-generated by Bright. #
# Do not modify!!!                             #
#                                              #
#                                              #
#                    Come on, guys. I mean it! #
################################################
"""Python wrapper for RMG.
"""
cimport fccomp
cimport fluence_point
cimport numpy as np
cimport pyne.stlcontainers
cimport reactor_parameters
from bright cimport cpp_fccomp
from bright cimport cpp_fluence_point
from bright cimport cpp_reactor_parameters
from libcpp.map cimport map as cpp_map
from libcpp.set cimport set as cpp_set
from libcpp.string cimport string as std_string
from libcpp.vector cimport vector as cpp_vector
from pyne cimport cpp_material
from pyne cimport material

from pyne import material
import fccomp
import fluence_point
import numpy as np
import pyne.stlcontainers
import reactor_parameters

np.import_array()

cdef class ReactorMG(fccomp.FCComp):
    """Multi-Group Reactor Fuel Cycle Component Class.  Daughter of FCComp class.
    
    Parameters
    ----------
    rp : ReactorParameters or None, optional 
        A special data structure that contains information on how to setup and 
        run the reactor.
    paramtrack : set of str or None, optional 
        A set of strings that represents what parameter data the reactor should 
        store and set.  Different reactor types may have different characteristic 
        parameters that are of interest.
    n : str, optional 
        The name of the reactor fuel cycle component instance.
    
    """

    # constuctors
    def __cinit__(self, *args, **kwargs):
        self._inst = NULL
        self._free_inst = True

        # cached property defaults
        self._A_HM_t = None
        self._BU0 = None
        self._BU_t = None
        self._E_g = None
        self._I = None
        self._J = None
        self._K = None
        self._K_ind = None
        self._K_ord = None
        self._MW_clad_t = None
        self._MW_cool_t = None
        self._MW_fuel_t = None
        self._N_clad_it = None
        self._N_cool_it = None
        self._N_fuel_it = None
        self._Phi = None
        self._Phi_t = None
        self._T_it = None
        self._Ti0 = None
        self._burn_times = None
        self._chemical_form_clad = None
        self._chemical_form_cool = None
        self._chemical_form_fuel = None
        self._k_t = None
        self._m_clad_it = None
        self._m_cool_it = None
        self._m_fuel_it = None
        self._mat_feed_act = None
        self._mat_feed_lan = None
        self._mat_feed_tru = None
        self._mat_feed_u = None
        self._mat_prod_act = None
        self._mat_prod_lan = None
        self._mat_prod_tru = None
        self._mat_prod_u = None
        self._n_clad_it = None
        self._n_cool_it = None
        self._n_fuel_it = None
        self._nearest_neighbors = None
        self._perturbed_fields = None
        self._phi = None
        self._phi_t = None
        self._time0 = None
        self._trans_consts = None

    def _reactormg_reactormg_0(self, n=""):
        """ReactorMG(self, n="")
        """
        self._inst = new cpp_reactormg.ReactorMG(std_string(<char *> n))
    
    
    def _reactormg_reactormg_1(self, paramtrack, n=""):
        """ReactorMG(self, paramtrack, n="")
        """
        cdef pyne.stlcontainers._SetStr paramtrack_proxy
        paramtrack_proxy = pyne.stlcontainers.SetStr(paramtrack, not isinstance(paramtrack, pyne.stlcontainers._SetStr))
        self._inst = new cpp_reactormg.ReactorMG(paramtrack_proxy.set_ptr[0], std_string(<char *> n))
    
    
    def _reactormg_reactormg_2(self, rp, n=""):
        """ReactorMG(self, rp, n="")
        """
        cdef reactor_parameters.ReactorParameters rp_proxy
        rp_proxy = <reactor_parameters.ReactorParameters> rp
        self._inst = new cpp_reactormg.ReactorMG((<cpp_reactor_parameters.ReactorParameters *> rp_proxy._inst)[0], std_string(<char *> n))
    
    
    def _reactormg_reactormg_3(self, rp, paramtrack, n=""):
        """ReactorMG(self, rp, paramtrack, n="")
        """
        cdef reactor_parameters.ReactorParameters rp_proxy
        cdef pyne.stlcontainers._SetStr paramtrack_proxy
        rp_proxy = <reactor_parameters.ReactorParameters> rp
        paramtrack_proxy = pyne.stlcontainers.SetStr(paramtrack, not isinstance(paramtrack, pyne.stlcontainers._SetStr))
        self._inst = new cpp_reactormg.ReactorMG((<cpp_reactor_parameters.ReactorParameters *> rp_proxy._inst)[0], paramtrack_proxy.set_ptr[0], std_string(<char *> n))
    
    
    _reactormg_reactormg_0_argtypes = frozenset(((0, str), ("n", str)))
    _reactormg_reactormg_1_argtypes = frozenset(((0, pyne.stlcontainers.SetStr), (1, str), ("paramtrack", pyne.stlcontainers.SetStr), ("n", str)))
    _reactormg_reactormg_2_argtypes = frozenset(((0, reactor_parameters.ReactorParameters), (1, str), ("rp", reactor_parameters.ReactorParameters), ("n", str)))
    _reactormg_reactormg_3_argtypes = frozenset(((0, reactor_parameters.ReactorParameters), (1, pyne.stlcontainers.SetStr), (2, str), ("rp", reactor_parameters.ReactorParameters), ("paramtrack", pyne.stlcontainers.SetStr), ("n", str)))
    
    def __init__(self, *args, **kwargs):
        """ReactorMG(self, rp, paramtrack, n="")
        """
        types = set([(i, type(a)) for i, a in enumerate(args)])
        types.update([(k, type(v)) for k, v in kwargs.iteritems()])
        # vtable-like dispatch for exactly matching types
        if types <= self._reactormg_reactormg_0_argtypes:
            self._reactormg_reactormg_0(*args, **kwargs)
            return
        if types <= self._reactormg_reactormg_1_argtypes:
            self._reactormg_reactormg_1(*args, **kwargs)
            return
        if types <= self._reactormg_reactormg_2_argtypes:
            self._reactormg_reactormg_2(*args, **kwargs)
            return
        if types <= self._reactormg_reactormg_3_argtypes:
            self._reactormg_reactormg_3(*args, **kwargs)
            return
        # duck-typed dispatch based on whatever works!
        try:
            self._reactormg_reactormg_0(*args, **kwargs)
            return
        except (RuntimeError, TypeError, NameError):
            pass
        try:
            self._reactormg_reactormg_1(*args, **kwargs)
            return
        except (RuntimeError, TypeError, NameError):
            pass
        try:
            self._reactormg_reactormg_2(*args, **kwargs)
            return
        except (RuntimeError, TypeError, NameError):
            pass
        try:
            self._reactormg_reactormg_3(*args, **kwargs)
            return
        except (RuntimeError, TypeError, NameError):
            pass
        raise RuntimeError('method __init__() could not be dispatched')
    

    # attributes
    property A_HM_t:
        """Atomic weight of heavy metal."""
        def __get__(self):
            cdef np.ndarray A_HM_t_proxy
            cdef np.npy_intp A_HM_t_proxy_shape[1]
            if self._A_HM_t is None:
                A_HM_t_proxy_shape[0] = <np.npy_intp> (<cpp_reactormg.ReactorMG *> self._inst).A_HM_t.size()
                A_HM_t_proxy = np.PyArray_SimpleNewFromData(1, A_HM_t_proxy_shape, np.NPY_FLOAT64, &(<cpp_reactormg.ReactorMG *> self._inst).A_HM_t[0])
                self._A_HM_t = A_HM_t_proxy
            return self._A_HM_t
    
        def __set__(self, value):
            cdef cpp_vector[double] value_proxy
            cdef int i
            cdef int value_size
            cdef double * value_data
            value_size = len(value)
            if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
                value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = value_data[i]
            else:
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = <double> value[i]
            (<cpp_reactormg.ReactorMG *> self._inst).A_HM_t = value_proxy
            self._A_HM_t = None
    
    
    property B:
        """This integer is the total number of batches in the fuel management scheme.  
        B is typically indexed by b."""
        def __get__(self):
            return int((<cpp_reactormg.ReactorMG *> self._inst).B)
    
        def __set__(self, value):
            (<cpp_reactormg.ReactorMG *> self._inst).B = value
    
    
    property BU0:
        """Burnup vector used in data library [MWd/kgIHM]."""
        def __get__(self):
            cdef np.ndarray BU0_proxy
            cdef np.npy_intp BU0_proxy_shape[1]
            if self._BU0 is None:
                BU0_proxy_shape[0] = <np.npy_intp> (<cpp_reactormg.ReactorMG *> self._inst).BU0.size()
                BU0_proxy = np.PyArray_SimpleNewFromData(1, BU0_proxy_shape, np.NPY_FLOAT64, &(<cpp_reactormg.ReactorMG *> self._inst).BU0[0])
                self._BU0 = BU0_proxy
            return self._BU0
    
        def __set__(self, value):
            cdef cpp_vector[double] value_proxy
            cdef int i
            cdef int value_size
            cdef double * value_data
            value_size = len(value)
            if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
                value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = value_data[i]
            else:
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = <double> value[i]
            (<cpp_reactormg.ReactorMG *> self._inst).BU0 = value_proxy
            self._BU0 = None
    
    
    property BU_t:
        """Burnup as a function of time [MWd/kgIHM]."""
        def __get__(self):
            cdef np.ndarray BU_t_proxy
            cdef np.npy_intp BU_t_proxy_shape[1]
            if self._BU_t is None:
                BU_t_proxy_shape[0] = <np.npy_intp> (<cpp_reactormg.ReactorMG *> self._inst).BU_t.size()
                BU_t_proxy = np.PyArray_SimpleNewFromData(1, BU_t_proxy_shape, np.NPY_FLOAT64, &(<cpp_reactormg.ReactorMG *> self._inst).BU_t[0])
                self._BU_t = BU_t_proxy
            return self._BU_t
    
        def __set__(self, value):
            cdef cpp_vector[double] value_proxy
            cdef int i
            cdef int value_size
            cdef double * value_data
            value_size = len(value)
            if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
                value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = value_data[i]
            else:
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = <double> value[i]
            (<cpp_reactormg.ReactorMG *> self._inst).BU_t = value_proxy
            self._BU_t = None
    
    
    property BUd:
        """Discharge Burnup [MWd/kgIHM]."""
        def __get__(self):
            return float((<cpp_reactormg.ReactorMG *> self._inst).BUd)
    
        def __set__(self, value):
            (<cpp_reactormg.ReactorMG *> self._inst).BUd = <double> value
    
    
    property E_g:
        """Energy bin boundaries [MeV].  Vector of doubles."""
        def __get__(self):
            cdef np.ndarray E_g_proxy
            cdef np.npy_intp E_g_proxy_shape[1]
            if self._E_g is None:
                E_g_proxy_shape[0] = <np.npy_intp> (<cpp_reactormg.ReactorMG *> self._inst).E_g.size()
                E_g_proxy = np.PyArray_SimpleNewFromData(1, E_g_proxy_shape, np.NPY_FLOAT64, &(<cpp_reactormg.ReactorMG *> self._inst).E_g[0])
                self._E_g = E_g_proxy
            return self._E_g
    
        def __set__(self, value):
            cdef cpp_vector[double] value_proxy
            cdef int i
            cdef int value_size
            cdef double * value_data
            value_size = len(value)
            if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
                value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = value_data[i]
            else:
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = <double> value[i]
            (<cpp_reactormg.ReactorMG *> self._inst).E_g = value_proxy
            self._E_g = None
    
    
    property G:
        """Number of energy bins.  Indexed by g for incident neutrons and h for 
        exiting neutrons."""
        def __get__(self):
            return int((<cpp_reactormg.ReactorMG *> self._inst).G)
    
        def __set__(self, value):
            (<cpp_reactormg.ReactorMG *> self._inst).G = value
    
    
    property I:
        """Set of nuclides that may be in mat_feed.  Indexed by i."""
        def __get__(self):
            cdef pyne.stlcontainers._SetInt I_proxy
            if self._I is None:
                I_proxy = pyne.stlcontainers.SetInt(False, False)
                I_proxy.set_ptr = &(<cpp_reactormg.ReactorMG *> self._inst).I
                self._I = I_proxy
            return self._I
    
        def __set__(self, value):
            cdef pyne.stlcontainers._SetInt value_proxy
            value_proxy = pyne.stlcontainers.SetInt(value, not isinstance(value, pyne.stlcontainers._SetInt))
            (<cpp_reactormg.ReactorMG *> self._inst).I = value_proxy.set_ptr[0]
            self._I = None
    
    
    property J:
        """Set of nuclides that may be in mat_prod.  Indexed by j."""
        def __get__(self):
            cdef pyne.stlcontainers._SetInt J_proxy
            if self._J is None:
                J_proxy = pyne.stlcontainers.SetInt(False, False)
                J_proxy.set_ptr = &(<cpp_reactormg.ReactorMG *> self._inst).J
                self._J = J_proxy
            return self._J
    
        def __set__(self, value):
            cdef pyne.stlcontainers._SetInt value_proxy
            value_proxy = pyne.stlcontainers.SetInt(value, not isinstance(value, pyne.stlcontainers._SetInt))
            (<cpp_reactormg.ReactorMG *> self._inst).J = value_proxy.set_ptr[0]
            self._J = None
    
    
    property K:
        """Set of nuclides that is the union of all nucs in mat_feed and all nucs in nuc_data.
        Indexed by k."""
        def __get__(self):
            cdef pyne.stlcontainers._SetInt K_proxy
            if self._K is None:
                K_proxy = pyne.stlcontainers.SetInt(False, False)
                K_proxy.set_ptr = &(<cpp_reactormg.ReactorMG *> self._inst).K
                self._K = K_proxy
            return self._K
    
        def __set__(self, value):
            cdef pyne.stlcontainers._SetInt value_proxy
            value_proxy = pyne.stlcontainers.SetInt(value, not isinstance(value, pyne.stlcontainers._SetInt))
            (<cpp_reactormg.ReactorMG *> self._inst).K = value_proxy.set_ptr[0]
            self._K = None
    
    
    property K_ind:
        """Lowest-to-highest map of J into matrix position."""
        def __get__(self):
            cdef pyne.stlcontainers._MapIntInt K_ind_proxy
            if self._K_ind is None:
                K_ind_proxy = pyne.stlcontainers.MapIntInt(False, False)
                K_ind_proxy.map_ptr = &(<cpp_reactormg.ReactorMG *> self._inst).K_ind
                self._K_ind = K_ind_proxy
            return self._K_ind
    
        def __set__(self, value):
            cdef pyne.stlcontainers._MapIntInt value_proxy
            value_proxy = pyne.stlcontainers.MapIntInt(value, not isinstance(value, pyne.stlcontainers._MapIntInt))
            (<cpp_reactormg.ReactorMG *> self._inst).K_ind = value_proxy.map_ptr[0]
            self._K_ind = None
    
    
    property K_num:
        """Size of K set."""
        def __get__(self):
            return int((<cpp_reactormg.ReactorMG *> self._inst).K_num)
    
        def __set__(self, value):
            (<cpp_reactormg.ReactorMG *> self._inst).K_num = value
    
    
    property K_ord:
        """Lowest-to-highest order of K."""
        def __get__(self):
            cdef np.ndarray K_ord_proxy
            cdef np.npy_intp K_ord_proxy_shape[1]
            if self._K_ord is None:
                K_ord_proxy_shape[0] = <np.npy_intp> (<cpp_reactormg.ReactorMG *> self._inst).K_ord.size()
                K_ord_proxy = np.PyArray_SimpleNewFromData(1, K_ord_proxy_shape, np.NPY_INT32, &(<cpp_reactormg.ReactorMG *> self._inst).K_ord[0])
                self._K_ord = K_ord_proxy
            return self._K_ord
    
        def __set__(self, value):
            cdef cpp_vector[int] value_proxy
            cdef int i
            cdef int value_size
            cdef int * value_data
            value_size = len(value)
            if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_INT32:
                value_data = <int *> np.PyArray_DATA(<np.ndarray> value)
                value_proxy = cpp_vector[int](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = value_data[i]
            else:
                value_proxy = cpp_vector[int](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = <int> value[i]
            (<cpp_reactormg.ReactorMG *> self._inst).K_ord = value_proxy
            self._K_ord = None
    
    
    property MW_clad_t:
        """Cladding Molecular Weight [amu]."""
        def __get__(self):
            cdef np.ndarray MW_clad_t_proxy
            cdef np.npy_intp MW_clad_t_proxy_shape[1]
            if self._MW_clad_t is None:
                MW_clad_t_proxy_shape[0] = <np.npy_intp> (<cpp_reactormg.ReactorMG *> self._inst).MW_clad_t.size()
                MW_clad_t_proxy = np.PyArray_SimpleNewFromData(1, MW_clad_t_proxy_shape, np.NPY_FLOAT64, &(<cpp_reactormg.ReactorMG *> self._inst).MW_clad_t[0])
                self._MW_clad_t = MW_clad_t_proxy
            return self._MW_clad_t
    
        def __set__(self, value):
            cdef cpp_vector[double] value_proxy
            cdef int i
            cdef int value_size
            cdef double * value_data
            value_size = len(value)
            if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
                value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = value_data[i]
            else:
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = <double> value[i]
            (<cpp_reactormg.ReactorMG *> self._inst).MW_clad_t = value_proxy
            self._MW_clad_t = None
    
    
    property MW_cool_t:
        """Coolant Molecular Weight [amu]."""
        def __get__(self):
            cdef np.ndarray MW_cool_t_proxy
            cdef np.npy_intp MW_cool_t_proxy_shape[1]
            if self._MW_cool_t is None:
                MW_cool_t_proxy_shape[0] = <np.npy_intp> (<cpp_reactormg.ReactorMG *> self._inst).MW_cool_t.size()
                MW_cool_t_proxy = np.PyArray_SimpleNewFromData(1, MW_cool_t_proxy_shape, np.NPY_FLOAT64, &(<cpp_reactormg.ReactorMG *> self._inst).MW_cool_t[0])
                self._MW_cool_t = MW_cool_t_proxy
            return self._MW_cool_t
    
        def __set__(self, value):
            cdef cpp_vector[double] value_proxy
            cdef int i
            cdef int value_size
            cdef double * value_data
            value_size = len(value)
            if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
                value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = value_data[i]
            else:
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = <double> value[i]
            (<cpp_reactormg.ReactorMG *> self._inst).MW_cool_t = value_proxy
            self._MW_cool_t = None
    
    
    property MW_fuel_t:
        """Fuel Molecular Weight [amu]."""
        def __get__(self):
            cdef np.ndarray MW_fuel_t_proxy
            cdef np.npy_intp MW_fuel_t_proxy_shape[1]
            if self._MW_fuel_t is None:
                MW_fuel_t_proxy_shape[0] = <np.npy_intp> (<cpp_reactormg.ReactorMG *> self._inst).MW_fuel_t.size()
                MW_fuel_t_proxy = np.PyArray_SimpleNewFromData(1, MW_fuel_t_proxy_shape, np.NPY_FLOAT64, &(<cpp_reactormg.ReactorMG *> self._inst).MW_fuel_t[0])
                self._MW_fuel_t = MW_fuel_t_proxy
            return self._MW_fuel_t
    
        def __set__(self, value):
            cdef cpp_vector[double] value_proxy
            cdef int i
            cdef int value_size
            cdef double * value_data
            value_size = len(value)
            if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
                value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = value_data[i]
            else:
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = <double> value[i]
            (<cpp_reactormg.ReactorMG *> self._inst).MW_fuel_t = value_proxy
            self._MW_fuel_t = None
    
    
    property N_clad_it:
        """Cladding Number Density [atoms/cm^3]."""
        def __get__(self):
            cdef pyne.stlcontainers._MapIntVectorDouble N_clad_it_proxy
            if self._N_clad_it is None:
                N_clad_it_proxy = pyne.stlcontainers.MapIntVectorDouble(False, False)
                N_clad_it_proxy.map_ptr = &(<cpp_reactormg.ReactorMG *> self._inst).N_clad_it
                self._N_clad_it = N_clad_it_proxy
            return self._N_clad_it
    
        def __set__(self, value):
            cdef pyne.stlcontainers._MapIntVectorDouble value_proxy
            value_proxy = pyne.stlcontainers.MapIntVectorDouble(value, not isinstance(value, pyne.stlcontainers._MapIntVectorDouble))
            (<cpp_reactormg.ReactorMG *> self._inst).N_clad_it = value_proxy.map_ptr[0]
            self._N_clad_it = None
    
    
    property N_cool_it:
        """Coolant Number Density [atoms/cm^3]."""
        def __get__(self):
            cdef pyne.stlcontainers._MapIntVectorDouble N_cool_it_proxy
            if self._N_cool_it is None:
                N_cool_it_proxy = pyne.stlcontainers.MapIntVectorDouble(False, False)
                N_cool_it_proxy.map_ptr = &(<cpp_reactormg.ReactorMG *> self._inst).N_cool_it
                self._N_cool_it = N_cool_it_proxy
            return self._N_cool_it
    
        def __set__(self, value):
            cdef pyne.stlcontainers._MapIntVectorDouble value_proxy
            value_proxy = pyne.stlcontainers.MapIntVectorDouble(value, not isinstance(value, pyne.stlcontainers._MapIntVectorDouble))
            (<cpp_reactormg.ReactorMG *> self._inst).N_cool_it = value_proxy.map_ptr[0]
            self._N_cool_it = None
    
    
    property N_fuel_it:
        """Fuel Number Density [atoms/cm^3]."""
        def __get__(self):
            cdef pyne.stlcontainers._MapIntVectorDouble N_fuel_it_proxy
            if self._N_fuel_it is None:
                N_fuel_it_proxy = pyne.stlcontainers.MapIntVectorDouble(False, False)
                N_fuel_it_proxy.map_ptr = &(<cpp_reactormg.ReactorMG *> self._inst).N_fuel_it
                self._N_fuel_it = N_fuel_it_proxy
            return self._N_fuel_it
    
        def __set__(self, value):
            cdef pyne.stlcontainers._MapIntVectorDouble value_proxy
            value_proxy = pyne.stlcontainers.MapIntVectorDouble(value, not isinstance(value, pyne.stlcontainers._MapIntVectorDouble))
            (<cpp_reactormg.ReactorMG *> self._inst).N_fuel_it = value_proxy.map_ptr[0]
            self._N_fuel_it = None
    
    
    property P_NL:
        """The reactor's non-leakage probability (float).  This is often used as 
        a calibration parameter."""
        def __get__(self):
            return float((<cpp_reactormg.ReactorMG *> self._inst).P_NL)
    
        def __set__(self, value):
            (<cpp_reactormg.ReactorMG *> self._inst).P_NL = <double> value
    
    
    property Phi:
        """Fluence [n/kb]."""
        def __get__(self):
            cdef np.ndarray Phi_proxy
            cdef np.npy_intp Phi_proxy_shape[1]
            if self._Phi is None:
                Phi_proxy_shape[0] = <np.npy_intp> (<cpp_reactormg.ReactorMG *> self._inst).Phi.size()
                Phi_proxy = np.PyArray_SimpleNewFromData(1, Phi_proxy_shape, np.NPY_FLOAT64, &(<cpp_reactormg.ReactorMG *> self._inst).Phi[0])
                self._Phi = Phi_proxy
            return self._Phi
    
        def __set__(self, value):
            cdef cpp_vector[double] value_proxy
            cdef int i
            cdef int value_size
            cdef double * value_data
            value_size = len(value)
            if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
                value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = value_data[i]
            else:
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = <double> value[i]
            (<cpp_reactormg.ReactorMG *> self._inst).Phi = value_proxy
            self._Phi = None
    
    
    property Phi_t:
        """Fluence as a function of time [n/kb]."""
        def __get__(self):
            cdef np.ndarray Phi_t_proxy
            cdef np.npy_intp Phi_t_proxy_shape[1]
            if self._Phi_t is None:
                Phi_t_proxy_shape[0] = <np.npy_intp> (<cpp_reactormg.ReactorMG *> self._inst).Phi_t.size()
                Phi_t_proxy = np.PyArray_SimpleNewFromData(1, Phi_t_proxy_shape, np.NPY_FLOAT64, &(<cpp_reactormg.ReactorMG *> self._inst).Phi_t[0])
                self._Phi_t = Phi_t_proxy
            return self._Phi_t
    
        def __set__(self, value):
            cdef cpp_vector[double] value_proxy
            cdef int i
            cdef int value_size
            cdef double * value_data
            value_size = len(value)
            if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
                value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = value_data[i]
            else:
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = <double> value[i]
            (<cpp_reactormg.ReactorMG *> self._inst).Phi_t = value_proxy
            self._Phi_t = None
    
    
    property Phid:
        """Discharge Fluence [n/kb]."""
        def __get__(self):
            return float((<cpp_reactormg.ReactorMG *> self._inst).Phid)
    
        def __set__(self, value):
            (<cpp_reactormg.ReactorMG *> self._inst).Phid = <double> value
    
    
    property S:
        """Number of burnup time steps."""
        def __get__(self):
            return int((<cpp_reactormg.ReactorMG *> self._inst).S)
    
        def __set__(self, value):
            (<cpp_reactormg.ReactorMG *> self._inst).S = value
    
    
    property S_O:
        """The number of slots (float) in a fuel assembly that are open.  Thus this is the 
        number of slots that do not contain a fuel pin and are instead filled in by coolant."""
        def __get__(self):
            return float((<cpp_reactormg.ReactorMG *> self._inst).S_O)
    
        def __set__(self, value):
            (<cpp_reactormg.ReactorMG *> self._inst).S_O = <double> value
    
    
    property S_T:
        """The total number of fuel pin slots (float) in a fuel assembly.  For a 17x17 bundle 
        this is 289.0."""
        def __get__(self):
            return float((<cpp_reactormg.ReactorMG *> self._inst).S_T)
    
        def __set__(self, value):
            (<cpp_reactormg.ReactorMG *> self._inst).S_T = <double> value
    
    
    property T_it:
        """Transformation Matrix [kg_i/kgIHM]."""
        def __get__(self):
            cdef pyne.stlcontainers._MapIntVectorDouble T_it_proxy
            if self._T_it is None:
                T_it_proxy = pyne.stlcontainers.MapIntVectorDouble(False, False)
                T_it_proxy.map_ptr = &(<cpp_reactormg.ReactorMG *> self._inst).T_it
                self._T_it = T_it_proxy
            return self._T_it
    
        def __set__(self, value):
            cdef pyne.stlcontainers._MapIntVectorDouble value_proxy
            value_proxy = pyne.stlcontainers.MapIntVectorDouble(value, not isinstance(value, pyne.stlcontainers._MapIntVectorDouble))
            (<cpp_reactormg.ReactorMG *> self._inst).T_it = value_proxy.map_ptr[0]
            self._T_it = None
    
    
    property Ti0:
        """Data library's transmutation vector [kg_i]."""
        def __get__(self):
            cdef pyne.stlcontainers._MapIntVectorDouble Ti0_proxy
            if self._Ti0 is None:
                Ti0_proxy = pyne.stlcontainers.MapIntVectorDouble(False, False)
                Ti0_proxy.map_ptr = &(<cpp_reactormg.ReactorMG *> self._inst).Ti0
                self._Ti0 = Ti0_proxy
            return self._Ti0
    
        def __set__(self, value):
            cdef pyne.stlcontainers._MapIntVectorDouble value_proxy
            value_proxy = pyne.stlcontainers.MapIntVectorDouble(value, not isinstance(value, pyne.stlcontainers._MapIntVectorDouble))
            (<cpp_reactormg.ReactorMG *> self._inst).Ti0 = value_proxy.map_ptr[0]
            self._Ti0 = None
    
    
    property V_clad:
        """The relative cladding region volume."""
        def __get__(self):
            return float((<cpp_reactormg.ReactorMG *> self._inst).V_clad)
    
        def __set__(self, value):
            (<cpp_reactormg.ReactorMG *> self._inst).V_clad = <double> value
    
    
    property V_cool:
        """The relative coolant region volume."""
        def __get__(self):
            return float((<cpp_reactormg.ReactorMG *> self._inst).V_cool)
    
        def __set__(self, value):
            (<cpp_reactormg.ReactorMG *> self._inst).V_cool = <double> value
    
    
    property V_fuel:
        """The relative fuel region volume."""
        def __get__(self):
            return float((<cpp_reactormg.ReactorMG *> self._inst).V_fuel)
    
        def __set__(self, value):
            (<cpp_reactormg.ReactorMG *> self._inst).V_fuel = <double> value
    
    
    property branch_ratio_cutoff:
        """The cutoff value (float) below which the bateman equations are not solved."""
        def __get__(self):
            return float((<cpp_reactormg.ReactorMG *> self._inst).branch_ratio_cutoff)
    
        def __set__(self, value):
            (<cpp_reactormg.ReactorMG *> self._inst).branch_ratio_cutoff = <double> value
    
    
    property bt_s:
        """Curent burnup time index.  burn_time == burn_times[bt_s]"""
        def __get__(self):
            return int((<cpp_reactormg.ReactorMG *> self._inst).bt_s)
    
        def __set__(self, value):
            (<cpp_reactormg.ReactorMG *> self._inst).bt_s = value
    
    
    property burn_regions:
        """Number of annular burn regions (int)."""
        def __get__(self):
            return int((<cpp_reactormg.ReactorMG *> self._inst).burn_regions)
    
        def __set__(self, value):
            (<cpp_reactormg.ReactorMG *> self._inst).burn_regions = value
    
    
    property burn_time:
        """Curent burnup time [d]."""
        def __get__(self):
            return float((<cpp_reactormg.ReactorMG *> self._inst).burn_time)
    
        def __set__(self, value):
            (<cpp_reactormg.ReactorMG *> self._inst).burn_time = <double> value
    
    
    property burn_times:
        """A non-negative, monotonically increasing numpy float array 
        (C++ vector<double>) of burnup times [days]."""
        def __get__(self):
            cdef np.ndarray burn_times_proxy
            cdef np.npy_intp burn_times_proxy_shape[1]
            if self._burn_times is None:
                burn_times_proxy_shape[0] = <np.npy_intp> (<cpp_reactormg.ReactorMG *> self._inst).burn_times.size()
                burn_times_proxy = np.PyArray_SimpleNewFromData(1, burn_times_proxy_shape, np.NPY_FLOAT64, &(<cpp_reactormg.ReactorMG *> self._inst).burn_times[0])
                self._burn_times = burn_times_proxy
            return self._burn_times
    
        def __set__(self, value):
            cdef cpp_vector[double] value_proxy
            cdef int i
            cdef int value_size
            cdef double * value_data
            value_size = len(value)
            if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
                value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = value_data[i]
            else:
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = <double> value[i]
            (<cpp_reactormg.ReactorMG *> self._inst).burn_times = value_proxy
            self._burn_times = None
    
    
    property burnup_via_constant:
        """Flag (str) for constant "flux" or "power" calculations."""
        def __get__(self):
            return str(<char *> (<cpp_reactormg.ReactorMG *> self._inst).burnup_via_constant.c_str())
    
        def __set__(self, value):
            (<cpp_reactormg.ReactorMG *> self._inst).burnup_via_constant = std_string(<char *> value)
    
    
    property chemical_form_clad:
        """This is the chemical form of cladding as a dictionary or other mapping.  
        This uses the same notation as fuel_form except that "IHM" is no longer 
        a valid key.  Cladding is often made from some zircalloy.
        """
        def __get__(self):
            cdef pyne.stlcontainers._MapStrDouble chemical_form_clad_proxy
            if self._chemical_form_clad is None:
                chemical_form_clad_proxy = pyne.stlcontainers.MapStrDouble(False, False)
                chemical_form_clad_proxy.map_ptr = &(<cpp_reactormg.ReactorMG *> self._inst).chemical_form_clad
                self._chemical_form_clad = chemical_form_clad_proxy
            return self._chemical_form_clad
    
        def __set__(self, value):
            cdef pyne.stlcontainers._MapStrDouble value_proxy
            value_proxy = pyne.stlcontainers.MapStrDouble(value, not isinstance(value, pyne.stlcontainers._MapStrDouble))
            (<cpp_reactormg.ReactorMG *> self._inst).chemical_form_clad = value_proxy.map_ptr[0]
            self._chemical_form_clad = None
    
    
    property chemical_form_cool:
        """This is the chemical form of coolant as a dictionary or other mapping.  
        This uses the same notation as fuel_form except that "IHM" is no longer 
        a valid key.  The term 'coolant' is used in preference over the term 
        'moderator' because not all reactors moderate neutrons."""
        def __get__(self):
            cdef pyne.stlcontainers._MapStrDouble chemical_form_cool_proxy
            if self._chemical_form_cool is None:
                chemical_form_cool_proxy = pyne.stlcontainers.MapStrDouble(False, False)
                chemical_form_cool_proxy.map_ptr = &(<cpp_reactormg.ReactorMG *> self._inst).chemical_form_cool
                self._chemical_form_cool = chemical_form_cool_proxy
            return self._chemical_form_cool
    
        def __set__(self, value):
            cdef pyne.stlcontainers._MapStrDouble value_proxy
            value_proxy = pyne.stlcontainers.MapStrDouble(value, not isinstance(value, pyne.stlcontainers._MapStrDouble))
            (<cpp_reactormg.ReactorMG *> self._inst).chemical_form_cool = value_proxy.map_ptr[0]
            self._chemical_form_cool = None
    
    
    property chemical_form_fuel:
        """This is the chemical form of fuel as a dictionary or other mapping.  Keys are 
        often strings that represent isotopes while values represent the corresponding 
        mass weights.  The heavy metal concentration by the key "IHM".  
        This will automatically fill in the nuclides in mat_feed for the "IHM" weight.  
        For example, LWRs typically use a UOX fuel form::
        
            ReactorMG.chemical_form_fuel = {"IHM": 1.0, "O16": 2.0}
        
        """
        def __get__(self):
            cdef pyne.stlcontainers._MapStrDouble chemical_form_fuel_proxy
            if self._chemical_form_fuel is None:
                chemical_form_fuel_proxy = pyne.stlcontainers.MapStrDouble(False, False)
                chemical_form_fuel_proxy.map_ptr = &(<cpp_reactormg.ReactorMG *> self._inst).chemical_form_fuel
                self._chemical_form_fuel = chemical_form_fuel_proxy
            return self._chemical_form_fuel
    
        def __set__(self, value):
            cdef pyne.stlcontainers._MapStrDouble value_proxy
            value_proxy = pyne.stlcontainers.MapStrDouble(value, not isinstance(value, pyne.stlcontainers._MapStrDouble))
            (<cpp_reactormg.ReactorMG *> self._inst).chemical_form_fuel = value_proxy.map_ptr[0]
            self._chemical_form_fuel = None
    
    
    property deltaR:
        """The :math:`\delta R` value of the core with the current mat_feed.  
        This is equal to the production rate minus the destruction rate at the 
        target burnup::
        
            deltaR = batch_average(target_BU, "P") - batch_average(target_BU, "D")
        
        This is computed via the calc_deltaR() method."""
        def __get__(self):
            return float((<cpp_reactormg.ReactorMG *> self._inst).deltaR)
    
        def __set__(self, value):
            (<cpp_reactormg.ReactorMG *> self._inst).deltaR = <double> value
    
    
    property flux:
        """The nominal flux value (float) that the library for this reactor type was 
        generated with.  Used to correctly weight batch-specific fluxes."""
        def __get__(self):
            return float((<cpp_reactormg.ReactorMG *> self._inst).flux)
    
        def __set__(self, value):
            (<cpp_reactormg.ReactorMG *> self._inst).flux = <double> value
    
    
    property k:
        """Core multiplication factor."""
        def __get__(self):
            return float((<cpp_reactormg.ReactorMG *> self._inst).k)
    
        def __set__(self, value):
            (<cpp_reactormg.ReactorMG *> self._inst).k = <double> value
    
    
    property k_t:
        """Multiplication factor of the core as a function of time."""
        def __get__(self):
            cdef np.ndarray k_t_proxy
            cdef np.npy_intp k_t_proxy_shape[1]
            if self._k_t is None:
                k_t_proxy_shape[0] = <np.npy_intp> (<cpp_reactormg.ReactorMG *> self._inst).k_t.size()
                k_t_proxy = np.PyArray_SimpleNewFromData(1, k_t_proxy_shape, np.NPY_FLOAT64, &(<cpp_reactormg.ReactorMG *> self._inst).k_t[0])
                self._k_t = k_t_proxy
            return self._k_t
    
        def __set__(self, value):
            cdef cpp_vector[double] value_proxy
            cdef int i
            cdef int value_size
            cdef double * value_data
            value_size = len(value)
            if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
                value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = value_data[i]
            else:
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = <double> value[i]
            (<cpp_reactormg.ReactorMG *> self._inst).k_t = value_proxy
            self._k_t = None
    
    
    property lattice_flag:
        """Flag (str) that represents what lattice type the fuel assemblies are arranged in.  
        Currently accepted values are "Planar", "Spherical", and "Cylindrical"."""
        def __get__(self):
            return str(<char *> (<cpp_reactormg.ReactorMG *> self._inst).lattice_flag.c_str())
    
        def __set__(self, value):
            (<cpp_reactormg.ReactorMG *> self._inst).lattice_flag = std_string(<char *> value)
    
    
    property libfile:
        """The path (str) to the reactor data library; usually something like "lwr_mg.h5"."""
        def __get__(self):
            return str(<char *> (<cpp_reactormg.ReactorMG *> self._inst).libfile.c_str())
    
        def __set__(self, value):
            (<cpp_reactormg.ReactorMG *> self._inst).libfile = std_string(<char *> value)
    
    
    property m_clad_it:
        """Cladding Mass Weight."""
        def __get__(self):
            cdef pyne.stlcontainers._MapIntVectorDouble m_clad_it_proxy
            if self._m_clad_it is None:
                m_clad_it_proxy = pyne.stlcontainers.MapIntVectorDouble(False, False)
                m_clad_it_proxy.map_ptr = &(<cpp_reactormg.ReactorMG *> self._inst).m_clad_it
                self._m_clad_it = m_clad_it_proxy
            return self._m_clad_it
    
        def __set__(self, value):
            cdef pyne.stlcontainers._MapIntVectorDouble value_proxy
            value_proxy = pyne.stlcontainers.MapIntVectorDouble(value, not isinstance(value, pyne.stlcontainers._MapIntVectorDouble))
            (<cpp_reactormg.ReactorMG *> self._inst).m_clad_it = value_proxy.map_ptr[0]
            self._m_clad_it = None
    
    
    property m_cool_it:
        """Coolant Mass Weight."""
        def __get__(self):
            cdef pyne.stlcontainers._MapIntVectorDouble m_cool_it_proxy
            if self._m_cool_it is None:
                m_cool_it_proxy = pyne.stlcontainers.MapIntVectorDouble(False, False)
                m_cool_it_proxy.map_ptr = &(<cpp_reactormg.ReactorMG *> self._inst).m_cool_it
                self._m_cool_it = m_cool_it_proxy
            return self._m_cool_it
    
        def __set__(self, value):
            cdef pyne.stlcontainers._MapIntVectorDouble value_proxy
            value_proxy = pyne.stlcontainers.MapIntVectorDouble(value, not isinstance(value, pyne.stlcontainers._MapIntVectorDouble))
            (<cpp_reactormg.ReactorMG *> self._inst).m_cool_it = value_proxy.map_ptr[0]
            self._m_cool_it = None
    
    
    property m_fuel_it:
        """Fuel Mass Weight."""
        def __get__(self):
            cdef pyne.stlcontainers._MapIntVectorDouble m_fuel_it_proxy
            if self._m_fuel_it is None:
                m_fuel_it_proxy = pyne.stlcontainers.MapIntVectorDouble(False, False)
                m_fuel_it_proxy.map_ptr = &(<cpp_reactormg.ReactorMG *> self._inst).m_fuel_it
                self._m_fuel_it = m_fuel_it_proxy
            return self._m_fuel_it
    
        def __set__(self, value):
            cdef pyne.stlcontainers._MapIntVectorDouble value_proxy
            value_proxy = pyne.stlcontainers.MapIntVectorDouble(value, not isinstance(value, pyne.stlcontainers._MapIntVectorDouble))
            (<cpp_reactormg.ReactorMG *> self._inst).m_fuel_it = value_proxy.map_ptr[0]
            self._m_fuel_it = None
    
    
    property mat_feed_act:
        """The input actininide material, mat_feed.sub_act()."""
        def __get__(self):
            cdef material._Material mat_feed_act_proxy
            if self._mat_feed_act is None:
                mat_feed_act_proxy = material.Material(free_mat=False)
                mat_feed_act_proxy.mat_pointer = &(<cpp_reactormg.ReactorMG *> self._inst).mat_feed_act
                self._mat_feed_act = mat_feed_act_proxy
            return self._mat_feed_act
    
        def __set__(self, value):
            cdef material._Material value_proxy
            value_proxy = material.Material(value, free_mat=not isinstance(value, material._Material))
            (<cpp_reactormg.ReactorMG *> self._inst).mat_feed_act = value_proxy.mat_pointer[0]
            self._mat_feed_act = None
    
    
    property mat_feed_lan:
        """The input lanthanide material, mat_feed.sub_lan()."""
        def __get__(self):
            cdef material._Material mat_feed_lan_proxy
            if self._mat_feed_lan is None:
                mat_feed_lan_proxy = material.Material(free_mat=False)
                mat_feed_lan_proxy.mat_pointer = &(<cpp_reactormg.ReactorMG *> self._inst).mat_feed_lan
                self._mat_feed_lan = mat_feed_lan_proxy
            return self._mat_feed_lan
    
        def __set__(self, value):
            cdef material._Material value_proxy
            value_proxy = material.Material(value, free_mat=not isinstance(value, material._Material))
            (<cpp_reactormg.ReactorMG *> self._inst).mat_feed_lan = value_proxy.mat_pointer[0]
            self._mat_feed_lan = None
    
    
    property mat_feed_tru:
        """The input transuranic material, mat_feed.sub_tru()."""
        def __get__(self):
            cdef material._Material mat_feed_tru_proxy
            if self._mat_feed_tru is None:
                mat_feed_tru_proxy = material.Material(free_mat=False)
                mat_feed_tru_proxy.mat_pointer = &(<cpp_reactormg.ReactorMG *> self._inst).mat_feed_tru
                self._mat_feed_tru = mat_feed_tru_proxy
            return self._mat_feed_tru
    
        def __set__(self, value):
            cdef material._Material value_proxy
            value_proxy = material.Material(value, free_mat=not isinstance(value, material._Material))
            (<cpp_reactormg.ReactorMG *> self._inst).mat_feed_tru = value_proxy.mat_pointer[0]
            self._mat_feed_tru = None
    
    
    property mat_feed_u:
        """The input uranium material, mat_feed.sub_u()."""
        def __get__(self):
            cdef material._Material mat_feed_u_proxy
            if self._mat_feed_u is None:
                mat_feed_u_proxy = material.Material(free_mat=False)
                mat_feed_u_proxy.mat_pointer = &(<cpp_reactormg.ReactorMG *> self._inst).mat_feed_u
                self._mat_feed_u = mat_feed_u_proxy
            return self._mat_feed_u
    
        def __set__(self, value):
            cdef material._Material value_proxy
            value_proxy = material.Material(value, free_mat=not isinstance(value, material._Material))
            (<cpp_reactormg.ReactorMG *> self._inst).mat_feed_u = value_proxy.mat_pointer[0]
            self._mat_feed_u = None
    
    
    property mat_prod_act:
        """The output actininide material, mat_prod.sub_act()."""
        def __get__(self):
            cdef material._Material mat_prod_act_proxy
            if self._mat_prod_act is None:
                mat_prod_act_proxy = material.Material(free_mat=False)
                mat_prod_act_proxy.mat_pointer = &(<cpp_reactormg.ReactorMG *> self._inst).mat_prod_act
                self._mat_prod_act = mat_prod_act_proxy
            return self._mat_prod_act
    
        def __set__(self, value):
            cdef material._Material value_proxy
            value_proxy = material.Material(value, free_mat=not isinstance(value, material._Material))
            (<cpp_reactormg.ReactorMG *> self._inst).mat_prod_act = value_proxy.mat_pointer[0]
            self._mat_prod_act = None
    
    
    property mat_prod_lan:
        """The output lanthanide material, mat_prod.sub_lan()."""
        def __get__(self):
            cdef material._Material mat_prod_lan_proxy
            if self._mat_prod_lan is None:
                mat_prod_lan_proxy = material.Material(free_mat=False)
                mat_prod_lan_proxy.mat_pointer = &(<cpp_reactormg.ReactorMG *> self._inst).mat_prod_lan
                self._mat_prod_lan = mat_prod_lan_proxy
            return self._mat_prod_lan
    
        def __set__(self, value):
            cdef material._Material value_proxy
            value_proxy = material.Material(value, free_mat=not isinstance(value, material._Material))
            (<cpp_reactormg.ReactorMG *> self._inst).mat_prod_lan = value_proxy.mat_pointer[0]
            self._mat_prod_lan = None
    
    
    property mat_prod_tru:
        """The output transuranic material, mat_prod.sub_tru()."""
        def __get__(self):
            cdef material._Material mat_prod_tru_proxy
            if self._mat_prod_tru is None:
                mat_prod_tru_proxy = material.Material(free_mat=False)
                mat_prod_tru_proxy.mat_pointer = &(<cpp_reactormg.ReactorMG *> self._inst).mat_prod_tru
                self._mat_prod_tru = mat_prod_tru_proxy
            return self._mat_prod_tru
    
        def __set__(self, value):
            cdef material._Material value_proxy
            value_proxy = material.Material(value, free_mat=not isinstance(value, material._Material))
            (<cpp_reactormg.ReactorMG *> self._inst).mat_prod_tru = value_proxy.mat_pointer[0]
            self._mat_prod_tru = None
    
    
    property mat_prod_u:
        """The output urnaium material, mat_prod.sub_u()."""
        def __get__(self):
            cdef material._Material mat_prod_u_proxy
            if self._mat_prod_u is None:
                mat_prod_u_proxy = material.Material(free_mat=False)
                mat_prod_u_proxy.mat_pointer = &(<cpp_reactormg.ReactorMG *> self._inst).mat_prod_u
                self._mat_prod_u = mat_prod_u_proxy
            return self._mat_prod_u
    
        def __set__(self, value):
            cdef material._Material value_proxy
            value_proxy = material.Material(value, free_mat=not isinstance(value, material._Material))
            (<cpp_reactormg.ReactorMG *> self._inst).mat_prod_u = value_proxy.mat_pointer[0]
            self._mat_prod_u = None
    
    
    property n_clad_it:
        """Cladding Atom Number Weight."""
        def __get__(self):
            cdef pyne.stlcontainers._MapIntVectorDouble n_clad_it_proxy
            if self._n_clad_it is None:
                n_clad_it_proxy = pyne.stlcontainers.MapIntVectorDouble(False, False)
                n_clad_it_proxy.map_ptr = &(<cpp_reactormg.ReactorMG *> self._inst).n_clad_it
                self._n_clad_it = n_clad_it_proxy
            return self._n_clad_it
    
        def __set__(self, value):
            cdef pyne.stlcontainers._MapIntVectorDouble value_proxy
            value_proxy = pyne.stlcontainers.MapIntVectorDouble(value, not isinstance(value, pyne.stlcontainers._MapIntVectorDouble))
            (<cpp_reactormg.ReactorMG *> self._inst).n_clad_it = value_proxy.map_ptr[0]
            self._n_clad_it = None
    
    
    property n_cool_it:
        """Coolant Atom Number Weight."""
        def __get__(self):
            cdef pyne.stlcontainers._MapIntVectorDouble n_cool_it_proxy
            if self._n_cool_it is None:
                n_cool_it_proxy = pyne.stlcontainers.MapIntVectorDouble(False, False)
                n_cool_it_proxy.map_ptr = &(<cpp_reactormg.ReactorMG *> self._inst).n_cool_it
                self._n_cool_it = n_cool_it_proxy
            return self._n_cool_it
    
        def __set__(self, value):
            cdef pyne.stlcontainers._MapIntVectorDouble value_proxy
            value_proxy = pyne.stlcontainers.MapIntVectorDouble(value, not isinstance(value, pyne.stlcontainers._MapIntVectorDouble))
            (<cpp_reactormg.ReactorMG *> self._inst).n_cool_it = value_proxy.map_ptr[0]
            self._n_cool_it = None
    
    
    property n_fuel_it:
        """Fuel Atom Number Weight."""
        def __get__(self):
            cdef pyne.stlcontainers._MapIntVectorDouble n_fuel_it_proxy
            if self._n_fuel_it is None:
                n_fuel_it_proxy = pyne.stlcontainers.MapIntVectorDouble(False, False)
                n_fuel_it_proxy.map_ptr = &(<cpp_reactormg.ReactorMG *> self._inst).n_fuel_it
                self._n_fuel_it = n_fuel_it_proxy
            return self._n_fuel_it
    
        def __set__(self, value):
            cdef pyne.stlcontainers._MapIntVectorDouble value_proxy
            value_proxy = pyne.stlcontainers.MapIntVectorDouble(value, not isinstance(value, pyne.stlcontainers._MapIntVectorDouble))
            (<cpp_reactormg.ReactorMG *> self._inst).n_fuel_it = value_proxy.map_ptr[0]
            self._n_fuel_it = None
    
    
    property nearest_neighbors:
        """Attribute that denotes the indices of the perturbation table which are 
        closest to the current state of the reactor (ie densities, burn_time, etc)."""
        def __get__(self):
            cdef np.ndarray nearest_neighbors_proxy
            cdef np.npy_intp nearest_neighbors_proxy_shape[1]
            if self._nearest_neighbors is None:
                nearest_neighbors_proxy_shape[0] = <np.npy_intp> (<cpp_reactormg.ReactorMG *> self._inst).nearest_neighbors.size()
                nearest_neighbors_proxy = np.PyArray_SimpleNewFromData(1, nearest_neighbors_proxy_shape, np.NPY_INT32, &(<cpp_reactormg.ReactorMG *> self._inst).nearest_neighbors[0])
                self._nearest_neighbors = nearest_neighbors_proxy
            return self._nearest_neighbors
    
        def __set__(self, value):
            cdef cpp_vector[int] value_proxy
            cdef int i
            cdef int value_size
            cdef int * value_data
            value_size = len(value)
            if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_INT32:
                value_data = <int *> np.PyArray_DATA(<np.ndarray> value)
                value_proxy = cpp_vector[int](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = value_data[i]
            else:
                value_proxy = cpp_vector[int](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = <int> value[i]
            (<cpp_reactormg.ReactorMG *> self._inst).nearest_neighbors = value_proxy
            self._nearest_neighbors = None
    
    
    property nperturbations:
        """Number of rows in the pertubtaion table.  Indexed by p."""
        def __get__(self):
            return int((<cpp_reactormg.ReactorMG *> self._inst).nperturbations)
    
        def __set__(self, value):
            (<cpp_reactormg.ReactorMG *> self._inst).nperturbations = value
    
    
    property perturbed_fields:
        """Mapping of the form {field_name: [min, max, delta]}."""
        def __get__(self):
            cdef pyne.stlcontainers._MapStrVectorDouble perturbed_fields_proxy
            if self._perturbed_fields is None:
                perturbed_fields_proxy = pyne.stlcontainers.MapStrVectorDouble(False, False)
                perturbed_fields_proxy.map_ptr = &(<cpp_reactormg.ReactorMG *> self._inst).perturbed_fields
                self._perturbed_fields = perturbed_fields_proxy
            return self._perturbed_fields
    
        def __set__(self, value):
            cdef pyne.stlcontainers._MapStrVectorDouble value_proxy
            value_proxy = pyne.stlcontainers.MapStrVectorDouble(value, not isinstance(value, pyne.stlcontainers._MapStrVectorDouble))
            (<cpp_reactormg.ReactorMG *> self._inst).perturbed_fields = value_proxy.map_ptr[0]
            self._perturbed_fields = None
    
    
    property phi:
        """Total flux [n/s/cm^2]."""
        def __get__(self):
            cdef np.ndarray phi_proxy
            cdef np.npy_intp phi_proxy_shape[1]
            if self._phi is None:
                phi_proxy_shape[0] = <np.npy_intp> (<cpp_reactormg.ReactorMG *> self._inst).phi.size()
                phi_proxy = np.PyArray_SimpleNewFromData(1, phi_proxy_shape, np.NPY_FLOAT64, &(<cpp_reactormg.ReactorMG *> self._inst).phi[0])
                self._phi = phi_proxy
            return self._phi
    
        def __set__(self, value):
            cdef cpp_vector[double] value_proxy
            cdef int i
            cdef int value_size
            cdef double * value_data
            value_size = len(value)
            if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
                value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = value_data[i]
            else:
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = <double> value[i]
            (<cpp_reactormg.ReactorMG *> self._inst).phi = value_proxy
            self._phi = None
    
    
    property phi_t:
        """Total flux as a function of time [n/s/cm^2]."""
        def __get__(self):
            cdef np.ndarray phi_t_proxy
            cdef np.npy_intp phi_t_proxy_shape[1]
            if self._phi_t is None:
                phi_t_proxy_shape[0] = <np.npy_intp> (<cpp_reactormg.ReactorMG *> self._inst).phi_t.size()
                phi_t_proxy = np.PyArray_SimpleNewFromData(1, phi_t_proxy_shape, np.NPY_FLOAT64, &(<cpp_reactormg.ReactorMG *> self._inst).phi_t[0])
                self._phi_t = phi_t_proxy
            return self._phi_t
    
        def __set__(self, value):
            cdef cpp_vector[double] value_proxy
            cdef int i
            cdef int value_size
            cdef double * value_data
            value_size = len(value)
            if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
                value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = value_data[i]
            else:
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = <double> value[i]
            (<cpp_reactormg.ReactorMG *> self._inst).phi_t = value_proxy
            self._phi_t = None
    
    
    property pitch:
        """The pitch or length (float) of the unit fuel pin cell [cm]."""
        def __get__(self):
            return float((<cpp_reactormg.ReactorMG *> self._inst).pitch)
    
        def __set__(self, value):
            (<cpp_reactormg.ReactorMG *> self._inst).pitch = <double> value
    
    
    property r_clad:
        """The radius (float) of the cladding region [cm]."""
        def __get__(self):
            return float((<cpp_reactormg.ReactorMG *> self._inst).r_clad)
    
        def __set__(self, value):
            (<cpp_reactormg.ReactorMG *> self._inst).r_clad = <double> value
    
    
    property r_fuel:
        """The radius (float) of the fuel region [cm]."""
        def __get__(self):
            return float((<cpp_reactormg.ReactorMG *> self._inst).r_fuel)
    
        def __set__(self, value):
            (<cpp_reactormg.ReactorMG *> self._inst).r_fuel = <double> value
    
    
    property r_void:
        """The radius (float) of the void region [cm]."""
        def __get__(self):
            return float((<cpp_reactormg.ReactorMG *> self._inst).r_void)
    
        def __set__(self, value):
            (<cpp_reactormg.ReactorMG *> self._inst).r_void = <double> value
    
    
    property rescale_hydrogen_xs:
        """Boolean to determine whether the reactor should rescale the Hydrogen-1 
        destruction rate in the coolant as a function of fluence.  The scaling factor 
        is calculated via the following equation
        
            .. math:: f(F) = 1.36927 - 0.01119 \cdot BU(F)
        
        This is typically not done for fast reactors but is a useful correction for LWRs."""
        def __get__(self):
            return bool((<cpp_reactormg.ReactorMG *> self._inst).rescale_hydrogen_xs)
    
        def __set__(self, value):
            (<cpp_reactormg.ReactorMG *> self._inst).rescale_hydrogen_xs = <bint> value
    
    
    property rho_clad:
        """The cladding region density.  A float in units of [g/cm^3]."""
        def __get__(self):
            return float((<cpp_reactormg.ReactorMG *> self._inst).rho_clad)
    
        def __set__(self, value):
            (<cpp_reactormg.ReactorMG *> self._inst).rho_clad = <double> value
    
    
    property rho_cool:
        """The coolant region density.  A float in units of [g/cm^3]."""
        def __get__(self):
            return float((<cpp_reactormg.ReactorMG *> self._inst).rho_cool)
    
        def __set__(self, value):
            (<cpp_reactormg.ReactorMG *> self._inst).rho_cool = <double> value
    
    
    property rho_fuel:
        """The fuel region density.  A float in units of [g/cm^3]."""
        def __get__(self):
            return float((<cpp_reactormg.ReactorMG *> self._inst).rho_fuel)
    
        def __set__(self, value):
            (<cpp_reactormg.ReactorMG *> self._inst).rho_fuel = <double> value
    
    
    property specific_power:
        """The specific power of the fuel (float) in units of [MW/kgIHM]"""
        def __get__(self):
            return float((<cpp_reactormg.ReactorMG *> self._inst).specific_power)
    
        def __set__(self, value):
            (<cpp_reactormg.ReactorMG *> self._inst).specific_power = <double> value
    
    
    property target_BU:
        """The reactor's target discharge burnup (float).  This is given 
        in units of [MWd/kgIHM].  Often the actual discharge burnup BUd does not 
        quite hit this value, but comes acceptably close."""
        def __get__(self):
            return float((<cpp_reactormg.ReactorMG *> self._inst).target_BU)
    
        def __set__(self, value):
            (<cpp_reactormg.ReactorMG *> self._inst).target_BU = <double> value
    
    
    property td:
        """Discharge time [days]."""
        def __get__(self):
            return float((<cpp_reactormg.ReactorMG *> self._inst).td)
    
        def __set__(self, value):
            (<cpp_reactormg.ReactorMG *> self._inst).td = <double> value
    
    
    property td_n:
        """Lower index of discharge time."""
        def __get__(self):
            return int((<cpp_reactormg.ReactorMG *> self._inst).td_n)
    
        def __set__(self, value):
            (<cpp_reactormg.ReactorMG *> self._inst).td_n = value
    
    
    property time0:
        """Time steps used in data library [d]."""
        def __get__(self):
            cdef np.ndarray time0_proxy
            cdef np.npy_intp time0_proxy_shape[1]
            if self._time0 is None:
                time0_proxy_shape[0] = <np.npy_intp> (<cpp_reactormg.ReactorMG *> self._inst).time0.size()
                time0_proxy = np.PyArray_SimpleNewFromData(1, time0_proxy_shape, np.NPY_FLOAT64, &(<cpp_reactormg.ReactorMG *> self._inst).time0[0])
                self._time0 = time0_proxy
            return self._time0
    
        def __set__(self, value):
            cdef cpp_vector[double] value_proxy
            cdef int i
            cdef int value_size
            cdef double * value_data
            value_size = len(value)
            if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
                value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = value_data[i]
            else:
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = <double> value[i]
            (<cpp_reactormg.ReactorMG *> self._inst).time0 = value_proxy
            self._time0 = None
    
    
    property trans_consts:
        """no docstring for trans_consts, please file a bug report!"""
        def __get__(self):
            cdef np.ndarray trans_consts_proxy
            cdef np.npy_intp trans_consts_proxy_shape[1]
            if self._trans_consts is None:
                trans_consts_proxy_shape[0] = <np.npy_intp> (<cpp_reactormg.ReactorMG *> self._inst).trans_consts.size()
                trans_consts_proxy = np.PyArray_SimpleNewFromData(1, trans_consts_proxy_shape, np.NPY_FLOAT64, &(<cpp_reactormg.ReactorMG *> self._inst).trans_consts[0])
                self._trans_consts = trans_consts_proxy
            return self._trans_consts
    
        def __set__(self, value):
            cdef cpp_vector[double] value_proxy
            cdef int i
            cdef int value_size
            cdef double * value_data
            value_size = len(value)
            if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
                value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = value_data[i]
            else:
                value_proxy = cpp_vector[double](<size_t> value_size)
                for i in range(value_size):
                    value_proxy[i] = <double> value[i]
            (<cpp_reactormg.ReactorMG *> self._inst).trans_consts = value_proxy
            self._trans_consts = None
    
    
    property tru_cr:
        """The transuranic conversion ratio of the reactor (float).  
        This is set via the calc_tru_cr() method."""
        def __get__(self):
            return float((<cpp_reactormg.ReactorMG *> self._inst).tru_cr)
    
        def __set__(self, value):
            (<cpp_reactormg.ReactorMG *> self._inst).tru_cr = <double> value
    
    
    property use_zeta:
        """Boolaean to determine whether the thermal disadvantage factor is employed or not.  
        LWRs typically set this as True while FRs have a False value."""
        def __get__(self):
            return bool((<cpp_reactormg.ReactorMG *> self._inst).use_zeta)
    
        def __set__(self, value):
            (<cpp_reactormg.ReactorMG *> self._inst).use_zeta = <bint> value
    
    
    # methods
    def BUd_bisection_method(self):
        """BUd_bisection_method(self)
        Calculates the maximum discharge burnup via the Bisection Method for a 
        given mat_feed in this reactor.  This iterates over values of BUd to find 
        a batch averaged multiplication factor that is closest to 1.0.
        
        Other root finding methods for determining maximum discharge burnup are 
        certainly possible.
        """
        (<cpp_reactormg.ReactorMG *> self._inst).BUd_bisection_method()
    
    
    def add_transmutation_chains(self, tc):
        """add_transmutation_chains(self, tc)
        no docstring for add_transmutation_chains, please file a bug report!"""
        cdef cpp_vector[int] tc_proxy
        cdef int i
        cdef int tc_size
        cdef int * tc_data
        tc_size = len(tc)
        if isinstance(tc, np.ndarray) and (<np.ndarray> tc).descr.type_num == np.NPY_INT32:
            tc_data = <int *> np.PyArray_DATA(<np.ndarray> tc)
            tc_proxy = cpp_vector[int](<size_t> tc_size)
            for i in range(tc_size):
                tc_proxy[i] = tc_data[i]
        else:
            tc_proxy = cpp_vector[int](<size_t> tc_size)
            for i in range(tc_size):
                tc_proxy[i] = <int> tc[i]
        (<cpp_reactormg.ReactorMG *> self._inst).add_transmutation_chains(tc_proxy)
    
    
    def assemble_multigroup_matrices(self):
        """assemble_multigroup_matrices(self)
        Folds mass weight in with cross-sections for current time step.
        """
        (<cpp_reactormg.ReactorMG *> self._inst).assemble_multigroup_matrices()
    
    
    def assemble_transmutation_matrices(self):
        """assemble_transmutation_matrices(self)
        Calculates the transmutation matrices for the current time step
        """
        (<cpp_reactormg.ReactorMG *> self._inst).assemble_transmutation_matrices()
    
    
    def batch_average_k(self, BUd):
        """batch_average_k(self, BUd)
        Finds the batch average k(F) when at discharge burnup BUd.  This function 
        is typically iterated over until a BUd is found such that k(F) = 1.0 + err.
        
        Parameters
        ----------
        BUd : float 
            The discharge burnup [MWd/kgIHM] to obtain a batch-averaged value for.
        
        Returns
        -------
        k : float 
            The batch averaged multiplication factor.
        
        """
        cdef double rtnval
        rtnval = (<cpp_reactormg.ReactorMG *> self._inst).batch_average_k(<double> BUd)
        return float(rtnval)
    
    
    def bateman(self, i, j, t):
        """bateman(self, i, j, t)
        no docstring for bateman, please file a bug report!"""
        cdef double rtnval
        rtnval = (<cpp_reactormg.ReactorMG *> self._inst).bateman(i, j, <double> t)
        return float(rtnval)
    
    
    def bateman_chain(self, i, j, c, t):
        """bateman_chain(self, i, j, c, t)
        no docstring for bateman_chain, please file a bug report!"""
        cdef double rtnval
        rtnval = (<cpp_reactormg.ReactorMG *> self._inst).bateman_chain(i, j, c, <double> t)
        return float(rtnval)
    
    
    def burnup_core(self):
        """burnup_core(self)
        This method generates a time-dependent parameters from an reactor's initial conditions.
        This includes all burnup and criticality calculations.  These time-dependent data
        are then used to determine discharge compositions and other parameters.
        """
        (<cpp_reactormg.ReactorMG *> self._inst).burnup_core()
    
    
    def _reactormg_calc_0(self):
        """calc(self)
        Since many other methods provide the computational heavy-lifting of 
        reactor calculations, the calc() method is relatively simple::
        
            self.mat_feed = input
            self.fold_mass_weights()
            self.BUd_bisection_method()
            self.calc_mat_prod()
            return self.mat_prod
        
        As you can see, all this function does is set burn an input stream to its maximum 
        discharge burnup and then reports on the output isotopics.
        
        Parameters
        ----------
        input : dict or Material or None, optional 
            If input is present, it set as the component's mat_feed.  If input is a nuclide 
            dictionary (zzaaam keys, float values), this dictionary is first converted into 
            a Material before being set as mat_feed.
        
        Returns
        -------
        output : Material 
            mat_prod
        
        """
        cdef cpp_material.Material rtnval
        cdef material._Material rtnval_proxy
        rtnval = (<cpp_fccomp.FCComp *> self._inst).calc()
        rtnval_proxy = material.Material()
        rtnval_proxy.mat_pointer[0] = rtnval
        return rtnval_proxy
    
    
    def _reactormg_calc_1(self, incomp):
        """calc(self, incomp)
        Since many other methods provide the computational heavy-lifting of 
        reactor calculations, the calc() method is relatively simple::
        
            self.mat_feed = input
            self.fold_mass_weights()
            self.BUd_bisection_method()
            self.calc_mat_prod()
            return self.mat_prod
        
        As you can see, all this function does is set burn an input stream to its maximum 
        discharge burnup and then reports on the output isotopics.
        
        Parameters
        ----------
        input : dict or Material or None, optional 
            If input is present, it set as the component's mat_feed.  If input is a nuclide 
            dictionary (zzaaam keys, float values), this dictionary is first converted into 
            a Material before being set as mat_feed.
        
        Returns
        -------
        output : Material 
            mat_prod
        
        """
        cdef pyne.stlcontainers._MapIntDouble incomp_proxy
        cdef cpp_material.Material rtnval
        cdef material._Material rtnval_proxy
        incomp_proxy = pyne.stlcontainers.MapIntDouble(incomp, not isinstance(incomp, pyne.stlcontainers._MapIntDouble))
        rtnval = (<cpp_fccomp.FCComp *> self._inst).calc(incomp_proxy.map_ptr[0])
        rtnval_proxy = material.Material()
        rtnval_proxy.mat_pointer[0] = rtnval
        return rtnval_proxy
    
    
    def _reactormg_calc_2(self, mat):
        """calc(self, mat)
        Since many other methods provide the computational heavy-lifting of 
        reactor calculations, the calc() method is relatively simple::
        
            self.mat_feed = input
            self.fold_mass_weights()
            self.BUd_bisection_method()
            self.calc_mat_prod()
            return self.mat_prod
        
        As you can see, all this function does is set burn an input stream to its maximum 
        discharge burnup and then reports on the output isotopics.
        
        Parameters
        ----------
        input : dict or Material or None, optional 
            If input is present, it set as the component's mat_feed.  If input is a nuclide 
            dictionary (zzaaam keys, float values), this dictionary is first converted into 
            a Material before being set as mat_feed.
        
        Returns
        -------
        output : Material 
            mat_prod
        
        """
        cdef material._Material mat_proxy
        cdef cpp_material.Material rtnval
        cdef material._Material rtnval_proxy
        mat_proxy = material.Material(mat, free_mat=not isinstance(mat, material._Material))
        rtnval = (<cpp_fccomp.FCComp *> self._inst).calc(mat_proxy.mat_pointer[0])
        rtnval_proxy = material.Material()
        rtnval_proxy.mat_pointer[0] = rtnval
        return rtnval_proxy
    
    
    _reactormg_calc_0_argtypes = frozenset()
    _reactormg_calc_1_argtypes = frozenset(((0, pyne.stlcontainers.MapIntDouble), ("incomp", pyne.stlcontainers.MapIntDouble)))
    _reactormg_calc_2_argtypes = frozenset(((0, material.Material), ("mat", material.Material)))
    
    def calc(self, *args, **kwargs):
        """calc(self, mat)
        Since many other methods provide the computational heavy-lifting of 
        reactor calculations, the calc() method is relatively simple::
        
            self.mat_feed = input
            self.fold_mass_weights()
            self.BUd_bisection_method()
            self.calc_mat_prod()
            return self.mat_prod
        
        As you can see, all this function does is set burn an input stream to its maximum 
        discharge burnup and then reports on the output isotopics.
        
        Parameters
        ----------
        input : dict or Material or None, optional 
            If input is present, it set as the component's mat_feed.  If input is a nuclide 
            dictionary (zzaaam keys, float values), this dictionary is first converted into 
            a Material before being set as mat_feed.
        
        Returns
        -------
        output : Material 
            mat_prod
        
        """
        types = set([(i, type(a)) for i, a in enumerate(args)])
        types.update([(k, type(v)) for k, v in kwargs.iteritems()])
        # vtable-like dispatch for exactly matching types
        if types <= self._reactormg_calc_0_argtypes:
            return self._reactormg_calc_0(*args, **kwargs)
        if types <= self._reactormg_calc_1_argtypes:
            return self._reactormg_calc_1(*args, **kwargs)
        if types <= self._reactormg_calc_2_argtypes:
            return self._reactormg_calc_2(*args, **kwargs)
        # duck-typed dispatch based on whatever works!
        try:
            return self._reactormg_calc_0(*args, **kwargs)
        except (RuntimeError, TypeError, NameError):
            pass
        try:
            return self._reactormg_calc_1(*args, **kwargs)
        except (RuntimeError, TypeError, NameError):
            pass
        try:
            return self._reactormg_calc_2(*args, **kwargs)
        except (RuntimeError, TypeError, NameError):
            pass
        raise RuntimeError('method calc() could not be dispatched')
    
    def calc_T_itd(self):
        """calc_T_itd(self)
        This function evaluates transmutation matrix at the discharge time td.
        The resultant isotopic dictionary is then converted into the mat_prod mass stream
        for this pass through the reactor.  Thus if ever you need to calculate mat_prod
        without going through calc(), use this function.
        """
        (<cpp_reactormg.ReactorMG *> self._inst).calc_T_itd()
    
    
    def calc_criticality(self):
        """calc_criticality(self)
        Performs the criticality calculation to find k for this time step.
        """
        (<cpp_reactormg.ReactorMG *> self._inst).calc_criticality()
    
    
    def calc_mass_weights(self):
        """calc_mass_weights(self)
        Calculates the mass weights for this time step.  Needed for 
        fold_mass_weights() method.
        """
        (<cpp_reactormg.ReactorMG *> self._inst).calc_mass_weights()
    
    
    def calc_mat_prod(self):
        """calc_mat_prod(self)
        This is a convenience function that wraps the transmutation matrix methods.  
        """
        (<cpp_reactormg.ReactorMG *> self._inst).calc_mat_prod()
    
    
    def calc_nearest_neighbors(self):
        """calc_nearest_neighbors(self)
        Calculates a sorted array that indexes the nearest neighbors of the 
        perturbations based off of the current state of the reactor.  The results may
        be found in the neareest_neighbors attribute.
        """
        (<cpp_reactormg.ReactorMG *> self._inst).calc_nearest_neighbors()
    
    
    def calc_sub_mats(self):
        """calc_sub_mats(self)
        This sets possibly relevant reactor input and output substreams.  
        Specifically, it calculates the attributes:
        
            * mat_feed_u
            * mat_feed_tru
            * mat_feed_lan
            * mat_feed_act
            * mat_prod_u
            * mat_prod_tru
            * mat_prod_lan
            * mat_prod_act
        
        """
        (<cpp_reactormg.ReactorMG *> self._inst).calc_sub_mats()
    
    
    def calc_transmutation(self):
        """calc_transmutation(self)
        no docstring for calc_transmutation, please file a bug report!"""
        (<cpp_reactormg.ReactorMG *> self._inst).calc_transmutation()
    
    
    def calc_tru_cr(self):
        """calc_tru_cr(self)
        This calculates and sets the transuranic conversion ratio tru_cr through: 
        
        .. math:: \mbox{tru\_cr} = \frac{\mbox{mat\_feed\_tru.mass} - \mbox{mat\_prod\_tru.mass}}{\frac{\mbox{BUd}}{935.0}}
        
        Returns
        -------
        tru_cr : float 
            The value of the transuranic conversion ratio just calculated.
        
        """
        cdef double rtnval
        rtnval = (<cpp_reactormg.ReactorMG *> self._inst).calc_tru_cr()
        return float(rtnval)
    
    
    def calc_zeta(self):
        """calc_zeta(self)
        no docstring for calc_zeta, please file a bug report!"""
        (<cpp_reactormg.ReactorMG *> self._inst).calc_zeta()
    
    
    def calibrate_P_NL_to_BUd(self):
        """calibrate_P_NL_to_BUd(self)
        Often times the non-leakage probability of a reactor is not known, 
        though the input isotopics and the target discharge burnup are.  This 
        function handles that situation by calibrating the non-leakage probability 
        of this reactor P_NL to hit its target burnup target_BU. Such a calibration 
        proceeds by bisection method as well.  This function is extremely useful for 
        benchmarking calculations.
        """
        (<cpp_reactormg.ReactorMG *> self._inst).calibrate_P_NL_to_BUd()
    
    
    def fluence_at_BU(self, BU):
        """fluence_at_BU(self, BU)
        This function takes a burnup value  and returns a special fluence point object.  
        The fluence point is an amalgamation of data where the at which the burnup occurs.
        This object instance FP contains three pieces of information::
            
            FP.f    #Index immediately lower than where BU achieved (int)
            FP.F    #Fluence value itself (float)
            FP.m    #Slope dBU/dF between points f and f+1 (double)
        
        Parameters
        ----------
        burnup : float 
            Burnup [MWd/kgIHM] at which to calculate the corresponding fluence.
        
        Returns
        -------
        fp : FluencePoint 
            A class containing fluence information.
        
        """
        cdef cpp_fluence_point.FluencePoint rtnval
        cdef fluence_point.FluencePoint rtnval_proxy
        rtnval = (<cpp_reactormg.ReactorMG *> self._inst).fluence_at_BU(<double> BU)
        rtnval_proxy = fluence_point.FluencePoint()
        (<cpp_fluence_point.FluencePoint *> rtnval_proxy._inst)[0] = rtnval
        return rtnval_proxy
    
    
    def fold_mass_weights(self):
        """fold_mass_weights(self)
        This method performs the all-important task of doing the isotopically-weighted 
        linear combination of raw data. In a very real sense this is what makes this 
        reactor *this specific reactor*.  The weights are taken as the values of mat_feed.  
        The raw data must have previously been read in from loadlib().  
        
        Warnings
        --------
        Anytime any reactor parameter whatsoever (mat_feed, P_NL, *etc*) is altered in 
        any way, the fold_mass_weights() function must be called to reset all of the 
        resultant data. If you are unsure, please call this function anyway to be safe.  
        There is little harm in calling it twice by accident.
        """
        (<cpp_reactormg.ReactorMG *> self._inst).fold_mass_weights()
    
    
    def init_core(self):
        """init_core(self)
        This method generates a time-dependent parameters from an reactor's initial conditions.
        This includes all burnup and criticality calculations.  These time-dependent data
        are then used to determine discharge compositions and other parameters.
        """
        (<cpp_reactormg.ReactorMG *> self._inst).init_core()
    
    
    def initialize(self, rp):
        """initialize(self, rp)
        The initialize() method for reactors copies all of the reactor specific 
        parameters to this instance. Additionally, it calculates and sets the volumes 
        VF and VC.
        
        Parameters
        ----------
        rp : ReactorParameters 
            A special data structure that contains information on how to setup and 
            run the reactor.
        
        """
        cdef reactor_parameters.ReactorParameters rp_proxy
        rp_proxy = <reactor_parameters.ReactorParameters> rp
        (<cpp_reactormg.ReactorMG *> self._inst).initialize((<cpp_reactor_parameters.ReactorParameters *> rp_proxy._inst)[0])
    
    
    def interpolate_cross_sections(self):
        """interpolate_cross_sections(self)
        This method iterpolates the isotopic, time-dependent cross-sections based 
        on the current state of the burn_time, bt_s, and nearest_neighbors attributes.  
        It is prudent to call the calc_nearest_neighbors() method before this one.
        """
        (<cpp_reactormg.ReactorMG *> self._inst).interpolate_cross_sections()
    
    
    def lattice_E_cylindrical(self, a, b):
        """lattice_E_cylindrical(self, a, b)
        no docstring for lattice_E_cylindrical, please file a bug report!"""
        (<cpp_reactormg.ReactorMG *> self._inst).lattice_E_cylindrical(<double> a, <double> b)
    
    
    def lattice_E_planar(self, a, b):
        """lattice_E_planar(self, a, b)
        no docstring for lattice_E_planar, please file a bug report!"""
        (<cpp_reactormg.ReactorMG *> self._inst).lattice_E_planar(<double> a, <double> b)
    
    
    def lattice_E_spherical(self, a, b):
        """lattice_E_spherical(self, a, b)
        no docstring for lattice_E_spherical, please file a bug report!"""
        (<cpp_reactormg.ReactorMG *> self._inst).lattice_E_spherical(<double> a, <double> b)
    
    
    def lattice_F_cylindrical(self, a, b):
        """lattice_F_cylindrical(self, a, b)
        no docstring for lattice_F_cylindrical, please file a bug report!"""
        (<cpp_reactormg.ReactorMG *> self._inst).lattice_F_cylindrical(<double> a, <double> b)
    
    
    def lattice_F_planar(self, a, b):
        """lattice_F_planar(self, a, b)
        no docstring for lattice_F_planar, please file a bug report!"""
        (<cpp_reactormg.ReactorMG *> self._inst).lattice_F_planar(<double> a, <double> b)
    
    
    def lattice_F_spherical(self, a, b):
        """lattice_F_spherical(self, a, b)
        no docstring for lattice_F_spherical, please file a bug report!"""
        (<cpp_reactormg.ReactorMG *> self._inst).lattice_F_spherical(<double> a, <double> b)
    
    
    def loadlib(self, lib="Reactor.h5"):
        """loadlib(self, lib="Reactor.h5")
        This method finds the HDF5 library for this reactor and extracts the 
        necessary information from it.  This method is typically called by the 
        constructor of the child reactor type object.  It must be called before 
        attempting to do any real computation.
        
        Parameters
        ----------
        lib : str, optional 
            Path to the reactor library.
        
        """
        (<cpp_reactormg.ReactorMG *> self._inst).loadlib(std_string(<char *> lib))
    
    
    def run_P_NL(self, temp_pnl):
        """run_P_NL(self, temp_pnl)
        Performs a reactor run for a specific non-leakage probability value.
        This requires that mat_feed be (meaningfully) set and is for use with 
        calibrate_P_NL_to_BUd().
        
        This function amounts to the following code::
        
            self.P_NL = pnl
            self.fold_mass_weights()
            self.BUd_bisection_method()
        
        Parameters
        ----------
        pnl : float 
            The new non-leakage probability for the reactor.
        
        """
        (<cpp_reactormg.ReactorMG *> self._inst).run_P_NL(<double> temp_pnl)
    
    


